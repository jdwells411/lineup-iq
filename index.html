<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#1a5276">
<link rel="manifest" href="manifest.json">
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore-compat.js"></script>
<title>LineupIQ</title>
<style>
  :root {
    --primary: #1a5276;
    --primary-light: #2980b9;
    --accent: #27ae60;
    --danger: #e74c3c;
    --warning: #f39c12;
    --bg: #f5f6fa;
    --card: #fff;
    --text: #2c3e50;
    --text-light: #7f8c8d;
    --border: #dcdde1;
    --shadow: 0 2px 8px rgba(0,0,0,0.08);
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg); color: var(--text); }

  /* Header */
  header { background: var(--primary); color: #fff; padding: 12px 24px; display: flex; align-items: center; justify-content: space-between; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
  header h1 { font-size: 1.5rem; font-weight: 700; }
  header h1 span { color: var(--accent); }

  /* Navigation */
  nav { background: #fff; border-bottom: 1px solid var(--border); padding: 0 24px; display: flex; gap: 0; }
  nav button { background: none; border: none; padding: 12px 20px; font-size: 0.95rem; color: var(--text-light); cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.2s; }
  nav button:hover { color: var(--text); background: #f0f0f0; }
  nav button.active { color: var(--primary); border-bottom-color: var(--primary); font-weight: 600; }

  /* Main content */
  main { max-width: 1200px; margin: 0 auto; padding: 24px; }
  .page { display: none; }
  .page.active { display: block; }

  /* Cards */
  .card { background: var(--card); border-radius: 8px; box-shadow: var(--shadow); padding: 24px; margin-bottom: 20px; }
  .card h2 { font-size: 1.2rem; margin-bottom: 16px; color: var(--primary); }
  .card h3 { font-size: 1rem; margin-bottom: 12px; }

  /* Forms */
  label { display: block; font-size: 0.85rem; font-weight: 600; margin-bottom: 4px; color: var(--text); }
  input, select { width: 100%; padding: 8px 12px; border: 1px solid var(--border); border-radius: 4px; font-size: 0.9rem; }
  input:focus, select:focus { outline: none; border-color: var(--primary-light); box-shadow: 0 0 0 2px rgba(41,128,185,0.2); }
  .form-row { display: flex; gap: 12px; margin-bottom: 12px; }
  .form-row > * { flex: 1; }

  /* Buttons */
  .btn { padding: 8px 16px; border: none; border-radius: 4px; font-size: 0.9rem; cursor: pointer; font-weight: 600; transition: all 0.2s; }
  .btn-primary { background: var(--primary); color: #fff; }
  .btn-primary:hover { background: var(--primary-light); }
  .btn-accent { background: var(--accent); color: #fff; }
  .btn-accent:hover { background: #219a52; }
  .btn-danger { background: var(--danger); color: #fff; }
  .btn-danger:hover { background: #c0392b; }
  .btn-warning { background: var(--warning); color: #fff; }
  .btn-warning:hover { background: #e67e22; }
  .btn-sm { padding: 4px 10px; font-size: 0.8rem; }
  .btn-outline { background: none; border: 1px solid var(--border); color: var(--text); }
  .btn-outline:hover { background: #f0f0f0; }
  .btn-group { display: flex; gap: 8px; margin-top: 12px; }

  /* Tables */
  table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
  th, td { padding: 8px 10px; text-align: left; border-bottom: 1px solid var(--border); }
  th { background: #f8f9fa; font-weight: 600; color: var(--text-light); text-transform: uppercase; font-size: 0.75rem; letter-spacing: 0.5px; }
  th.skill-header { writing-mode: initial; transform: rotate(-45deg); transform-origin: bottom left; white-space: nowrap; padding: 4px; font-size: 0.65rem; height: 100px; vertical-align: bottom; text-transform: none; }
  tr:hover { background: #f8f9fa; }

  /* Skill rating */
  .skill-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px; }
  .skill-item { display: flex; align-items: center; gap: 8px; }
  .skill-item label { margin-bottom: 0; flex: 1; font-size: 0.82rem; }
  .skill-item select { width: 60px; flex: 0 0 60px; }

  /* Checkbox toggle */
  .toggle-row { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
  .toggle-row label { margin-bottom: 0; }
  input[type="checkbox"] { width: auto; }

  /* Tags */
  .tag { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; }
  .tag-pitcher { background: #ebf5fb; color: #2980b9; }
  .tag-catcher { background: #fef9e7; color: #f39c12; }
  .tag-yes { background: #eafaf1; color: #27ae60; }
  .tag-no { background: #fdedec; color: #e74c3c; }

  /* Schedule table */
  .schedule-row { display: flex; align-items: center; gap: 8px; padding: 8px 0; border-bottom: 1px solid var(--border); }
  .schedule-row:last-child { border-bottom: none; }

  /* Status badges */
  .badge { display: inline-block; padding: 3px 10px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; }
  .badge-pending { background: #fef9e7; color: #f39c12; }
  .badge-complete { background: #eafaf1; color: #27ae60; }
  .badge-active { background: #ebf5fb; color: #2980b9; }

  /* Game card */
  .game-card { border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 12px; cursor: pointer; transition: all 0.2s; }
  .game-card:hover { border-color: var(--primary-light); box-shadow: 0 2px 8px rgba(41,128,185,0.15); }
  .game-card .game-header { display: flex; justify-content: space-between; align-items: center; }
  .game-card .game-header h3 { font-size: 1rem; }
  .game-card .game-details { display: flex; gap: 20px; margin-top: 8px; font-size: 0.85rem; color: var(--text-light); }
  .game-card .game-details span { display: flex; align-items: center; gap: 4px; }
  .dugout-indicator { font-weight: 600; }
  .dugout-home { color: var(--accent); }
  .dugout-away { color: var(--warning); }

  /* Lineup grid */
  .lineup-grid { overflow-x: auto; }
  .lineup-grid table th, .lineup-grid table td { text-align: center; min-width: 80px; }
  .lineup-grid table td:first-child, .lineup-grid table th:first-child { text-align: left; min-width: 140px; position: sticky; left: 0; background: #fff; z-index: 1; }
  .lineup-grid table th:first-child { background: #f8f9fa; }
  .lineup-grid select { width: 100%; font-size: 0.8rem; padding: 4px; }
  .lineup-grid .bench-cell { background: #fef9e7; }
  .lineup-grid .absent-row { opacity: 0.4; }

  /* Baseball field */
  .field-container { position: relative; width: 520px; height: 480px; margin: 20px auto; }
  .field-svg { width: 100%; height: 100%; }
  .field-pos { position: absolute; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; }
  .field-pos .pos-dot { width: 62px; height: 62px; border-radius: 50%; background: #fff; border: 2px solid var(--primary); display: flex; flex-direction: column; align-items: center; justify-content: center; box-shadow: 0 2px 6px rgba(0,0,0,0.2); z-index: 2; position: relative; }
  .field-pos .pos-label { font-size: 0.6rem; font-weight: 700; color: var(--primary); text-transform: uppercase; letter-spacing: 0.5px; }
  .field-pos .pos-player { font-size: 0.72rem; font-weight: 600; color: var(--text); white-space: nowrap; }
  /* Positions on the field ‚Äî realistic baseball layout */
  .fpos-P  { left: 229px; top: 252px; }
  .fpos-C  { left: 229px; top: 395px; }
  .fpos-1B { left: 365px; top: 255px; }
  .fpos-2B { left: 300px; top: 150px; }
  .fpos-SS { left: 160px; top: 150px; }
  .fpos-3B { left: 85px;  top: 255px; }
  .fpos-LF { left: 30px;  top: 60px; }
  .fpos-CF { left: 229px; top: 15px; }
  .fpos-RF { left: 428px; top: 60px; }

  /* Bench list */
  .bench-list { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px; }
  .bench-player { background: #fef9e7; padding: 4px 12px; border-radius: 16px; font-size: 0.8rem; font-weight: 600; }

  /* Warnings */
  .warning-box { background: #fef9e7; border-left: 4px solid var(--warning); padding: 12px 16px; margin-bottom: 12px; border-radius: 0 4px 4px 0; }
  .warning-box .warning-title { font-weight: 600; color: var(--warning); margin-bottom: 4px; }
  .error-box { background: #fdedec; border-left: 4px solid var(--danger); padding: 12px 16px; margin-bottom: 12px; border-radius: 0 4px 4px 0; }
  .error-box .error-title { font-weight: 600; color: var(--danger); margin-bottom: 4px; }
  .success-box { background: #eafaf1; border-left: 4px solid var(--accent); padding: 12px 16px; margin-bottom: 12px; border-radius: 0 4px 4px 0; }

  /* Inning tabs */
  .inning-tabs { display: flex; gap: 4px; margin-bottom: 16px; }
  .inning-tab { padding: 8px 16px; border: 1px solid var(--border); border-radius: 4px 4px 0 0; cursor: pointer; font-weight: 600; font-size: 0.85rem; background: #f8f9fa; }
  .inning-tab.active { background: var(--primary); color: #fff; border-color: var(--primary); }

  /* Battery plan grid */
  .battery-grid { display: grid; grid-template-columns: auto repeat(6, 1fr); gap: 8px; align-items: center; }
  .battery-grid label { font-size: 0.85rem; }
  .battery-grid select { font-size: 0.8rem; padding: 4px; }

  /* Season stats */
  .stat-bar { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
  .stat-bar-fill { height: 8px; border-radius: 4px; background: var(--primary-light); }
  .stat-bar-track { flex: 1; height: 8px; border-radius: 4px; background: #ecf0f1; overflow: hidden; }
  .stat-met { color: var(--accent); }
  .stat-unmet { color: var(--danger); font-weight: 600; }

  /* Empty state */
  .empty-state { text-align: center; padding: 40px; color: var(--text-light); }
  .empty-state h3 { margin-bottom: 8px; }

  /* Modal */
  .modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 100; align-items: center; justify-content: center; }
  .modal-overlay.active { display: flex; }
  .modal { background: #fff; border-radius: 8px; padding: 24px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; }
  .modal h2 { margin-bottom: 16px; }
  .modal-actions { display: flex; justify-content: flex-end; gap: 8px; margin-top: 16px; }

  /* Print */
  @media print {

  /* Batting order drag list */
  .batting-list { list-style: none; padding: 0; margin: 0; max-width: 400px; }
  .batting-item { display: flex; align-items: center; gap: 12px; padding: 10px 12px; margin-bottom: 4px; background: #fff; border: 1px solid var(--border); border-radius: 6px; cursor: grab; user-select: none; transition: all 0.15s; }
  .batting-item:active { cursor: grabbing; }
  .batting-item.dragging { opacity: 0.4; background: #ebf5fb; }
  .batting-item.drag-over { border-color: var(--primary); border-width: 2px; }
  .batting-order-num { width: 28px; height: 28px; border-radius: 50%; background: var(--primary); color: #fff; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; font-weight: 700; flex-shrink: 0; }
  .batting-grip { color: var(--text-light); font-size: 1.1rem; flex-shrink: 0; cursor: grab; }
  .batting-name { flex: 1; font-weight: 600; font-size: 0.9rem; }
  .batting-arrows { display: none; }
  .batting-arrows button { background: none; border: 1px solid var(--border); width: 24px; height: 20px; cursor: pointer; font-size: 0.65rem; display: flex; align-items: center; justify-content: center; color: var(--text-light); }
  .batting-arrows button:hover { background: #f0f0f0; color: var(--text); }
  .batting-arrows button:first-child { border-radius: 4px 4px 0 0; }
  .batting-arrows button:last-child { border-radius: 0 0 4px 4px; border-top: none; }
    header, nav, .btn, .no-print { display: none !important; }
    .page { display: block !important; }
    .card { box-shadow: none; border: 1px solid #ddd; page-break-inside: avoid; }
    body { background: #fff; }
  }

  /* Responsive */
  @media (max-width: 768px) {
    nav { overflow-x: auto; }
    .form-row { flex-direction: column; }
    .field-container { transform: scale(0.8); transform-origin: top center; }
  }
</style>
</head>
<body>

<!-- Login Screen -->
<div id="loginScreen" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:var(--bg);z-index:999;display:flex;align-items:center;justify-content:center;">
  <div class="card" style="max-width:360px;text-align:center;">
    <h1 style="color:var(--primary);margin-bottom:4px;">Lineup<span style="color:var(--accent);">IQ</span></h1>
    <p style="color:var(--text-light);margin-bottom:20px;">Little League Majors</p>
    <label style="text-align:left;">Enter Access Code</label>
    <input type="password" id="loginPassword" placeholder="Access code" onkeydown="if(event.key==='Enter')checkPassword()" style="margin-bottom:12px;">
    <button class="btn btn-primary" onclick="checkPassword()" style="width:100%;">Enter</button>
    <p id="loginError" style="color:var(--danger);margin-top:8px;font-size:0.85rem;display:none;">Incorrect code. Try again.</p>
  </div>
</div>

<header id="appHeader" style="display:none;">
  <h1>Lineup<span>IQ</span> <span style="font-size:0.55rem;font-weight:400;opacity:0.6;vertical-align:middle;">v2026.02.14.01.19</span></h1>
  <div style="font-size:0.85rem;opacity:0.8;">Little League Majors</div>
</header>

<nav id="mainNav" style="display:none;">
  <button data-page="roster" class="active">Roster</button>
  <button data-page="schedule">Schedule</button>
  <button data-page="games">Games</button>
  <button data-page="season">Season Stats</button>
  <button data-page="rules">Rules</button>
</nav>

<main id="appMain" style="display:none;">

<!-- ===== ROSTER PAGE ===== -->
<div id="page-roster" class="page active">
  <div class="card">
    <h2>Team Roster</h2>
    <p style="color:var(--text-light);margin-bottom:16px;">Add players, rate their skills (1-5), and flag pitchers/catchers. Roster persists all season.</p>
    <div class="btn-group no-print" style="margin-bottom:16px;">
      <button class="btn btn-primary" onclick="showPlayerModal()">+ Add Player</button>
      <button class="btn btn-outline" onclick="loadSeedData()">Load Sample Data</button>

    </div>
    <div id="rosterTable"></div>
  </div>
</div>

<!-- ===== SCHEDULE PAGE ===== -->
<div id="page-schedule" class="page">
  <div class="card">
    <h2>Season Schedule</h2>
    <p style="color:var(--text-light);margin-bottom:16px;">Enter all games for the season. Home team gets the 3rd base dugout.</p>
    <div class="btn-group no-print" style="margin-bottom:16px;">
      <button class="btn btn-primary" onclick="showGameModal()">+ Add Game</button>
    </div>
    <div id="scheduleTable"></div>
  </div>
</div>

<!-- ===== GAMES PAGE (per-game lineup) ===== -->
<div id="page-games" class="page">
  <div id="gamesList"></div>
  <div id="gameDetail" style="display:none;"></div>
</div>

<!-- ===== SEASON STATS PAGE ===== -->
<div id="page-season" class="page">
  <div class="card">
    <h2>Season Statistics</h2>
    <p style="color:var(--text-light);margin-bottom:16px;">Cumulative stats across all games. Flags players who haven't met season requirements.</p>
    <div id="seasonStats"></div>
  </div>
</div>

<!-- ===== RULES PAGE ===== -->
<div id="page-rules" class="page">
  <div class="card">
    <h2>Rules Configuration</h2>
    <p style="color:var(--text-light);margin-bottom:16px;">Adjust game rules, skill attributes, and coaching strategy. Changes take effect on next lineup generation.</p>
    
    <h3 style="margin-top:16px;">Game Rules</h3>
    <div class="form-row">
      <div><label>Innings per Game</label><input type="number" id="rule-innings" min="1" max="9" value="6" onchange="saveRules()"></div>
      <div><label>Players per Roster</label><input type="number" id="rule-rosterSize" min="9" max="20" value="12" onchange="saveRules()"></div>
      <div><label>Fielders per Inning</label><input type="number" id="rule-fielders" min="9" max="9" value="9" onchange="saveRules()"></div>
    </div>
    <div class="form-row">
      <div><label>Min Infield Innings (per game)</label><input type="number" id="rule-minInfield" min="0" max="6" value="2" onchange="saveRules()"></div>
      <div><label>Min Pitching (season): Batters Faced</label><input type="number" id="rule-minPitchBatters" min="0" value="1" onchange="saveRules()"></div>
      <div><label>Home Dugout</label>
        <select id="rule-homeDugout" onchange="saveRules()">
          <option value="3B">3rd Base Side</option>
          <option value="1B">1st Base Side</option>
        </select>
      </div>
    </div>

    <h3 style="margin-top:24px;">Pitcher/Catcher Warnings</h3>
    <div class="form-row">
      <div><label>Catcher innings before no-pitch</label><input type="number" id="rule-catcherInningsLimit" min="1" value="4" onchange="saveRules()"></div>
      <div><label>Pitcher pitches before no-catch</label><input type="number" id="rule-pitcherPitchLimit" min="1" value="41" onchange="saveRules()"></div>
      <div><label>Pitcher pitches (‚â§3 inn) no return to catch</label><input type="number" id="rule-pitcherReturnLimit" min="1" value="21" onchange="saveRules()"></div>
    </div>

    <h3 style="margin-top:24px;">Skill Attributes</h3>
    <p style="color:var(--text-light);font-size:0.85rem;margin-bottom:12px;">These attributes are rated 1-5 for each player.</p>
    <div id="skillAttrList"></div>
    <div class="btn-group" style="margin-top:8px;">
      <input type="text" id="newSkillAttr" placeholder="New attribute name" style="width:200px;">
      <button class="btn btn-outline btn-sm" onclick="addSkillAttribute()">+ Add</button>
    </div>

    <h3 style="margin-top:24px;">Coaching Strategy</h3>
    <div id="strategyList"></div>
    <div class="btn-group" style="margin-top:8px;">
      <input type="text" id="newStrategy" placeholder="New strategy rule" style="width:400px;">
      <button class="btn btn-outline btn-sm" onclick="addStrategy()">+ Add</button>
    </div>
  </div>
</div>

</main>

<!-- Player Modal -->
<div class="modal-overlay" id="playerModal">
  <div class="modal">
    <h2 id="playerModalTitle">Add Player</h2>
    <input type="hidden" id="playerId">
    <div class="form-row">
      <div><label>First Name</label><input type="text" id="playerFirst"></div>
      <div><label>Last Name</label><input type="text" id="playerLast"></div>
      <div><label>Jersey #</label><input type="number" id="playerNumber" min="0" max="99"></div>
    </div>
    <div class="toggle-row">
      <input type="checkbox" id="playerCanPitch"><label for="playerCanPitch">Can Pitch</label>
    </div>
    <div class="toggle-row">
      <input type="checkbox" id="playerCanCatch"><label for="playerCanCatch">Can Catch (catcher position)</label>
    </div>
    <h3 style="margin-top:16px;">Skill Ratings (1-5)</h3>
    <div class="skill-grid" id="playerSkills"></div>
    <div class="modal-actions">
      <button class="btn btn-outline" onclick="closePlayerModal()">Cancel</button>
      <button class="btn btn-primary" onclick="savePlayer()">Save</button>
    </div>
  </div>
</div>

<!-- Game Modal -->
<div class="modal-overlay" id="gameModal">
  <div class="modal">
    <h2 id="gameModalTitle">Add Game</h2>
    <input type="hidden" id="gameId">
    <div class="form-row">
      <div><label>Opponent</label><input type="text" id="gameOpponent"></div>
      <div><label>Date</label><input type="date" id="gameDate"></div>
    </div>
    <div class="form-row">
      <div><label>Start Time</label><input type="time" id="gameTime"></div>
      <div><label>Location</label><input type="text" id="gameLocation"></div>
    </div>
    <div class="form-row">
      <div>
        <label>Home / Away</label>
        <select id="gameHomeAway">
          <option value="home">Home</option>
          <option value="away">Away</option>
        </select>
      </div>
      <div></div>
    </div>
    <div class="modal-actions">
      <button class="btn btn-outline" onclick="closeGameModal()">Cancel</button>
      <button class="btn btn-primary" onclick="saveGame()">Save</button>
    </div>
  </div>
</div>

<!-- Evaluation Modal -->
<div class="modal-overlay" id="evalModal">
  <div class="modal" style="max-width:700px;">
    <h2 id="evalModalTitle">Player Evaluation</h2>
    <input type="hidden" id="evalPlayerId">
    <div id="evalContent"></div>
    <div style="margin-top:16px;">
      <label>Notes (optional)</label>
      <input type="text" id="evalNotes" placeholder="e.g., Arm got stronger after practice drills">
    </div>
    <div class="modal-actions">
      <button class="btn btn-outline" onclick="closeEvalModal()">Cancel</button>
      <button class="btn btn-accent" onclick="saveEvaluation()">Save Evaluation</button>
    </div>
    <div id="evalHistorySection" style="margin-top:24px;border-top:1px solid var(--border);padding-top:16px;">
      <h3>Evaluation History</h3>
      <div id="evalHistoryList"></div>
    </div>
  </div>
</div>

<script>
// ========== FIREBASE INIT ==========
firebase.initializeApp({
  apiKey: "AIzaSyDleUDApX92_HE42hpwa4ZFh2nnwCFsjUU",
  authDomain: "lineup-iq.firebaseapp.com",
  projectId: "lineup-iq",
  storageBucket: "lineup-iq.firebasestorage.app",
  messagingSenderId: "29422573339",
  appId: "1:29422573339:web:2b36703ba7dfdbe8a8a5be",
  measurementId: "G-K7DB1G1DCT"
});
const db = firebase.firestore();

// ========== DATA LAYER ==========
const STORAGE_KEYS = { players: 'liq_players', games: 'liq_games', rules: 'liq_rules', lineups: 'liq_lineups', battingOrder: 'liq_batting', evalHistory: 'liq_evals' };

// In-memory cache synced with Firestore
const _cache = {};

// Load from cache (populated by real-time listeners)
function load(key) { return _cache[key] || null; }

// Save to both cache and Firestore
function save(key, data) {
  _cache[key] = data;
  db.collection('appData').doc(key).set({ value: JSON.stringify(data) })
    .catch(err => console.error('Firestore save error:', err));
}

// Real-time listeners ‚Äî keeps all clients in sync
const COLLECTION_KEYS = Object.values(STORAGE_KEYS);
function initRealtimeSync() {
  COLLECTION_KEYS.forEach(key => {
    db.collection('appData').doc(key).onSnapshot(doc => {
      if (doc.exists) {
        try {
          _cache[key] = JSON.parse(doc.data().value);
        } catch { _cache[key] = null; }
      }
      refreshCurrentPage();
    });
  });
}

// Re-render the active page when data changes from another client
function refreshCurrentPage() {
  const active = document.querySelector('#mainNav button.active');
  if (!active) return;
  const page = active.dataset.page;
  if (page === 'roster') renderRoster();
  else if (page === 'games') {
    // Don't reset to game list if a game is currently open
    if (currentGameId && document.getElementById('gameDetail').style.display !== 'none') {
      if (currentLineup) renderLineupOutput();
    } else {
      renderGamesList();
    }
  }
  else if (page === 'season') renderSeasonStats();
  else if (page === 'rules') renderRulesPage();
  else if (page === 'schedule') renderSchedule();
}

const DEFAULT_SKILLS = [
  'Fielding Ability', 'Outfield Ability', 'Infield Catching Ability',
  'Arm Accuracy', 'Arm Strength', 'Agility', 'Baseball IQ',
  'Coachability', 'Attitude', 'Impact on Teammates'
];

const DEFAULT_STRATEGIES = [
  'SS must be a strong infield player',
  '1B must have good hands (catching ability) but doesn\'t need a strong arm',
  'Weaker 2B must be paired with strong SS and strong 1B',
  'Weaker 3B must be paired with a stronger LF',
  'Infield should stay strong ‚Äî weaker infielders surrounded by stronger ones',
  'Pitcher and catcher assignments set by coach before generation'
];

const POSITIONS = ['P','C','1B','2B','SS','3B','LF','CF','RF'];
const INFIELD = ['1B','2B','SS','3B'];

function getPlayers() { return load(STORAGE_KEYS.players) || []; }
function savePlayers(p) { save(STORAGE_KEYS.players, p); }
function getGames() { return load(STORAGE_KEYS.games) || []; }
function saveGames(g) { save(STORAGE_KEYS.games, g); }
function getLineups() { return load(STORAGE_KEYS.lineups) || {}; }
function saveLineups(l) { save(STORAGE_KEYS.lineups, l); }
function getBattingOrder() { return load(STORAGE_KEYS.battingOrder) || []; }
function saveBattingOrder(b) { save(STORAGE_KEYS.battingOrder, b); }
function getEvalHistory() { return load(STORAGE_KEYS.evalHistory) || []; }
function saveEvalHistory(h) { save(STORAGE_KEYS.evalHistory, h); }

function getRules() {
  const defaults = {
    innings: 6, rosterSize: 12, fielders: 9, minInfield: 2,
    minPitchBatters: 1, homeDugout: '3B',
    catcherInningsLimit: 4, pitcherPitchLimit: 41, pitcherReturnLimit: 21,
    skillAttributes: [...DEFAULT_SKILLS],
    strategies: [...DEFAULT_STRATEGIES]
  };
  return { ...defaults, ...(load(STORAGE_KEYS.rules) || {}) };
}
function saveRulesData(r) { save(STORAGE_KEYS.rules, r); }

// ========== NAVIGATION ==========
document.querySelectorAll('#mainNav button').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#mainNav button').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('page-' + btn.dataset.page).classList.add('active');
    if (btn.dataset.page === 'games') renderGamesList();
    if (btn.dataset.page === 'season') renderSeasonStats();
    if (btn.dataset.page === 'rules') renderRulesPage();
    if (btn.dataset.page === 'roster') renderRoster();
    if (btn.dataset.page === 'schedule') renderSchedule();
  });
});

// ========== ROSTER ==========
function renderRoster() {
  const players = getPlayers();
  const rules = getRules();
  const el = document.getElementById('rosterTable');
  if (players.length === 0) {
    el.innerHTML = '<div class="empty-state"><h3>No players yet</h3><p>Add players to your roster or load sample data.</p></div>';
    return;
  }
  let html = '<table><thead><tr><th>#</th><th>Name</th><th>P</th><th>C</th>';
  rules.skillAttributes.forEach(s => { html += `<th class="skill-header">${s}</th>`; });
  html += '<th>Actions</th></tr></thead><tbody>';
  players.sort((a,b) => a.number - b.number).forEach(p => {
    html += `<tr><td>${p.number}</td><td>${p.firstName} ${p.lastName}</td>`;
    html += `<td>${p.canPitch ? '<span class="tag tag-pitcher">P</span>' : ''}</td>`;
    html += `<td>${p.canCatch ? '<span class="tag tag-catcher">C</span>' : ''}</td>`;
    rules.skillAttributes.forEach(s => {
      const val = (p.skills && p.skills[s]) || '-';
      html += `<td>${val}</td>`;
    });
    html += `<td>
      <button class="btn btn-accent btn-sm" onclick="showEvalModal('${p.id}')">Edit</button>
      <button class="btn btn-danger btn-sm" onclick="deletePlayer('${p.id}')">‚úï</button>
    </td>`;
    html += '</tr>';
  });
  html += '</tbody></table>';
  el.innerHTML = html;
}

function showPlayerModal(id) {
  const rules = getRules();
  const modal = document.getElementById('playerModal');
  const skillsDiv = document.getElementById('playerSkills');
  
  // Build skill rating inputs
  let skillHtml = '';
  rules.skillAttributes.forEach(s => {
    skillHtml += `<div class="skill-item"><label>${s}</label><select data-skill="${s}">`;
    for (let i = 0; i <= 5; i++) skillHtml += `<option value="${i}">${i === 0 ? '-' : i}</option>`;
    skillHtml += '</select></div>';
  });
  skillsDiv.innerHTML = skillHtml;

  if (id) {
    const p = getPlayers().find(x => x.id === id);
    document.getElementById('playerModalTitle').textContent = 'Edit Player';
    document.getElementById('playerId').value = p.id;
    document.getElementById('playerFirst').value = p.firstName;
    document.getElementById('playerLast').value = p.lastName;
    document.getElementById('playerNumber').value = p.number;
    document.getElementById('playerCanPitch').checked = p.canPitch;
    document.getElementById('playerCanCatch').checked = p.canCatch;
    rules.skillAttributes.forEach(s => {
      const sel = skillsDiv.querySelector(`[data-skill="${s}"]`);
      if (sel && p.skills && p.skills[s]) sel.value = p.skills[s];
    });
  } else {
    document.getElementById('playerModalTitle').textContent = 'Add Player';
    document.getElementById('playerId').value = '';
    document.getElementById('playerFirst').value = '';
    document.getElementById('playerLast').value = '';
    document.getElementById('playerNumber').value = '';
    document.getElementById('playerCanPitch').checked = false;
    document.getElementById('playerCanCatch').checked = false;
  }
  modal.classList.add('active');
}

function closePlayerModal() { document.getElementById('playerModal').classList.remove('active'); }

function editPlayer(id) { showPlayerModal(id); }

function savePlayer() {
  const rules = getRules();
  const players = getPlayers();
  const id = document.getElementById('playerId').value || ('p_' + Date.now());
  const firstName = document.getElementById('playerFirst').value.trim();
  const lastName = document.getElementById('playerLast').value.trim();
  const number = parseInt(document.getElementById('playerNumber').value) || 0;
  if (!firstName || !lastName) { alert('First and last name required.'); return; }
  
  const skills = {};
  rules.skillAttributes.forEach(s => {
    const sel = document.querySelector(`#playerSkills [data-skill="${s}"]`);
    if (sel) skills[s] = parseInt(sel.value) || 0;
  });

  const player = {
    id, firstName, lastName, number,
    canPitch: document.getElementById('playerCanPitch').checked,
    canCatch: document.getElementById('playerCanCatch').checked,
    skills
  };

  const idx = players.findIndex(p => p.id === id);
  if (idx >= 0) players[idx] = player; else players.push(player);
  savePlayers(players);
  closePlayerModal();
  renderRoster();
}

function deletePlayer(id) {
  if (!confirm('Remove this player from the roster?')) return;
  savePlayers(getPlayers().filter(p => p.id !== id));
  renderRoster();
}

// ========== PLAYER EVALUATION ==========
function showEvalModal(id) {
  const player = getPlayers().find(p => p.id === id);
  const rules = getRules();
  const modal = document.getElementById('evalModal');
  
  document.getElementById('evalPlayerId').value = id;
  document.getElementById('evalModalTitle').textContent = `#${player.number} ${player.firstName} ${player.lastName}`;
  document.getElementById('evalNotes').value = '';

  // Build name/number fields + before/after skill grid
  let html = `<div class="form-row" style="margin-bottom:16px;">
    <div><label>First Name</label><input type="text" id="evalFirstName" value="${player.firstName}"></div>
    <div><label>Last Name</label><input type="text" id="evalLastName" value="${player.lastName}"></div>
    <div><label>Jersey #</label><input type="number" id="evalNumber" value="${player.number}" min="0" max="99"></div>
  </div>`;
  html += '<table style="width:100%;"><thead><tr><th style="text-align:left;">Skill</th><th style="text-align:center;">Current</th><th style="text-align:center;">New</th><th></th></tr></thead><tbody>';
  rules.skillAttributes.forEach(attr => {
    const current = (player.skills && player.skills[attr]) || 0;
    html += `<tr>
      <td style="font-size:0.85rem;font-weight:600;">${attr}</td>
      <td style="text-align:center;"><span class="badge badge-active">${current || '-'}</span></td>
      <td style="text-align:center;">
        <select data-eval-skill="${attr}" style="width:60px;text-align:center;">`;
    for (let i = 0; i <= 5; i++) html += `<option value="${i}" ${i === current ? 'selected' : ''}>${i === 0 ? '-' : i}</option>`;
    html += `</select></td>
      <td id="evalDiff_${attr.replace(/\s/g,'_')}" style="font-size:0.8rem;width:40px;text-align:center;"></td>
    </tr>`;
  });
  html += '</tbody></table>';

  // Pitcher/catcher flags
  html += `<div style="margin-top:12px;display:flex;gap:20px;">
    <div class="toggle-row"><input type="checkbox" id="evalCanPitch" ${player.canPitch ? 'checked' : ''}><label for="evalCanPitch">Can Pitch</label></div>
    <div class="toggle-row"><input type="checkbox" id="evalCanCatch" ${player.canCatch ? 'checked' : ''}><label for="evalCanCatch">Can Catch</label></div>
  </div>`;

  document.getElementById('evalContent').innerHTML = html;

  // Add change listeners to show diff arrows
  document.querySelectorAll('[data-eval-skill]').forEach(sel => {
    sel.addEventListener('change', () => updateEvalDiffs(player));
  });

  // Render history
  renderEvalHistory(id);
  modal.classList.add('active');
}

function updateEvalDiffs(player) {
  const rules = getRules();
  rules.skillAttributes.forEach(attr => {
    const current = (player.skills && player.skills[attr]) || 0;
    const sel = document.querySelector(`[data-eval-skill="${attr}"]`);
    const newVal = parseInt(sel.value) || 0;
    const diffEl = document.getElementById('evalDiff_' + attr.replace(/\s/g, '_'));
    if (!diffEl) return;
    if (newVal > current) {
      diffEl.innerHTML = `<span style="color:var(--accent);font-weight:700;">‚ñ≤ +${newVal - current}</span>`;
    } else if (newVal < current) {
      diffEl.innerHTML = `<span style="color:var(--danger);font-weight:700;">‚ñº ${newVal - current}</span>`;
    } else {
      diffEl.innerHTML = '';
    }
  });
}

function closeEvalModal() { document.getElementById('evalModal').classList.remove('active'); }

function saveEvaluation() {
  const id = document.getElementById('evalPlayerId').value;
  const players = getPlayers();
  const player = players.find(p => p.id === id);
  const rules = getRules();
  const notes = document.getElementById('evalNotes').value.trim();

  // Get name/number updates
  const newFirst = document.getElementById('evalFirstName').value.trim();
  const newLast = document.getElementById('evalLastName').value.trim();
  const newNumber = parseInt(document.getElementById('evalNumber').value) || 0;
  if (!newFirst || !newLast) { alert('First and last name required.'); return; }

  // Capture changes
  const changes = [];
  if (newFirst !== player.firstName) changes.push({ attr: 'First Name', from: player.firstName, to: newFirst });
  if (newLast !== player.lastName) changes.push({ attr: 'Last Name', from: player.lastName, to: newLast });
  if (newNumber !== player.number) changes.push({ attr: 'Jersey #', from: player.number, to: newNumber });

  const newSkills = {};
  rules.skillAttributes.forEach(attr => {
    const sel = document.querySelector(`[data-eval-skill="${attr}"]`);
    const oldVal = (player.skills && player.skills[attr]) || 0;
    const newVal = parseInt(sel.value) || 0;
    newSkills[attr] = newVal;
    if (newVal !== oldVal) {
      changes.push({ attr, from: oldVal, to: newVal });
    }
  });

  const oldPitch = player.canPitch;
  const oldCatch = player.canCatch;
  const newPitch = document.getElementById('evalCanPitch').checked;
  const newCatch = document.getElementById('evalCanCatch').checked;
  if (newPitch !== oldPitch) changes.push({ attr: 'Can Pitch', from: oldPitch, to: newPitch });
  if (newCatch !== oldCatch) changes.push({ attr: 'Can Catch', from: oldCatch, to: newCatch });

  if (changes.length === 0 && !notes) {
    alert('No changes to save.');
    return;
  }

  // Save evaluation to history
  const history = getEvalHistory();
  history.push({
    playerId: id,
    playerName: `#${player.number} ${player.firstName} ${player.lastName}`,
    date: new Date().toISOString(),
    changes,
    notes
  });
  saveEvalHistory(history);

  // Update player
  player.firstName = newFirst;
  player.lastName = newLast;
  player.number = newNumber;
  player.skills = newSkills;
  player.canPitch = newPitch;
  player.canCatch = newCatch;
  savePlayers(players);

  closeEvalModal();
  renderRoster();
  alert(`Evaluation saved: ${changes.length} change(s) recorded.`);
}

function renderEvalHistory(playerId) {
  const history = getEvalHistory().filter(e => e.playerId === playerId);
  const el = document.getElementById('evalHistoryList');

  if (history.length === 0) {
    el.innerHTML = '<p style="color:var(--text-light);font-size:0.85rem;">No previous evaluations.</p>';
    return;
  }

  let html = '';
  [...history].reverse().forEach(entry => {
    const date = new Date(entry.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    html += `<div style="margin-bottom:12px;padding:8px 12px;background:#f8f9fa;border-radius:6px;font-size:0.82rem;">
      <div style="font-weight:600;margin-bottom:4px;">üìÖ ${date}</div>`;
    entry.changes.forEach(c => {
      if (typeof c.from === 'boolean') {
        html += `<div>${c.attr}: ${c.from ? 'Yes' : 'No'} ‚Üí ${c.to ? 'Yes' : 'No'}</div>`;
      } else {
        const arrow = c.to > c.from ? `<span style="color:var(--accent);">‚ñ≤</span>` : `<span style="color:var(--danger);">‚ñº</span>`;
        html += `<div>${c.attr}: ${c.from || '-'} ‚Üí ${c.to || '-'} ${arrow}</div>`;
      }
    });
    if (entry.notes) html += `<div style="margin-top:4px;color:var(--text-light);font-style:italic;">üí¨ ${entry.notes}</div>`;
    html += '</div>';
  });
  el.innerHTML = html;
}

// ========== SCHEDULE ==========
function renderSchedule() {
  const games = getGames();
  const rules = getRules();
  const el = document.getElementById('scheduleTable');
  if (games.length === 0) {
    el.innerHTML = '<div class="empty-state"><h3>No games scheduled</h3><p>Add games to your season schedule.</p></div>';
    return;
  }
  const sorted = [...games].sort((a,b) => (a.date + a.time).localeCompare(b.date + b.time));
  let html = '<table><thead><tr><th>#</th><th>Date</th><th>Time</th><th>Opponent</th><th>Location</th><th>Home/Away</th><th>Dugout</th><th>Status</th><th>Actions</th></tr></thead><tbody>';
  sorted.forEach((g, i) => {
    const dugout = g.homeAway === 'home' ? rules.homeDugout : (rules.homeDugout === '3B' ? '1B' : '3B');
    const dugoutClass = g.homeAway === 'home' ? 'dugout-home' : 'dugout-away';
    const lineups = getLineups();
    const status = lineups[g.id] ? 'complete' : 'pending';
    const dateStr = g.date ? new Date(g.date + 'T00:00').toLocaleDateString('en-US', {weekday:'short', month:'short', day:'numeric'}) : '-';
    const timeStr = g.time ? formatTime(g.time) : '-';
    html += `<tr>
      <td>${i+1}</td>
      <td>${dateStr}</td>
      <td>${timeStr}</td>
      <td><strong>${g.opponent}</strong></td>
      <td>${g.location || '-'}</td>
      <td>${g.homeAway === 'home' ? 'Home' : 'Away'}</td>
      <td><span class="dugout-indicator ${dugoutClass}">${dugout} side</span></td>
      <td><span class="badge badge-${status}">${status === 'complete' ? 'Lineup Set' : 'Pending'}</span></td>
      <td>
        <button class="btn btn-outline btn-sm" onclick="editGame('${g.id}')">Edit</button>
        <button class="btn btn-danger btn-sm" onclick="deleteGame('${g.id}')">‚úï</button>
      </td>
    </tr>`;
  });
  html += '</tbody></table>';
  el.innerHTML = html;
}

function formatTime(t) {
  const [h, m] = t.split(':').map(Number);
  const ampm = h >= 12 ? 'PM' : 'AM';
  const hr = h % 12 || 12;
  return `${hr}:${m.toString().padStart(2,'0')} ${ampm}`;
}

function showGameModal(id) {
  const modal = document.getElementById('gameModal');
  if (id) {
    const g = getGames().find(x => x.id === id);
    document.getElementById('gameModalTitle').textContent = 'Edit Game';
    document.getElementById('gameId').value = g.id;
    document.getElementById('gameOpponent').value = g.opponent;
    document.getElementById('gameDate').value = g.date;
    document.getElementById('gameTime').value = g.time;
    document.getElementById('gameLocation').value = g.location;
    document.getElementById('gameHomeAway').value = g.homeAway;
  } else {
    document.getElementById('gameModalTitle').textContent = 'Add Game';
    document.getElementById('gameId').value = '';
    document.getElementById('gameOpponent').value = '';
    document.getElementById('gameDate').value = '';
    document.getElementById('gameTime').value = '';
    document.getElementById('gameLocation').value = '';
    document.getElementById('gameHomeAway').value = 'home';
  }
  modal.classList.add('active');
}

function closeGameModal() { document.getElementById('gameModal').classList.remove('active'); }
function editGame(id) { showGameModal(id); }

function saveGame() {
  const games = getGames();
  const id = document.getElementById('gameId').value || ('g_' + Date.now());
  const opponent = document.getElementById('gameOpponent').value.trim();
  if (!opponent) { alert('Opponent name required.'); return; }
  const game = {
    id, opponent,
    date: document.getElementById('gameDate').value,
    time: document.getElementById('gameTime').value,
    location: document.getElementById('gameLocation').value.trim(),
    homeAway: document.getElementById('gameHomeAway').value
  };
  const idx = games.findIndex(g => g.id === id);
  if (idx >= 0) games[idx] = game; else games.push(game);
  saveGames(games);
  closeGameModal();
  renderSchedule();
}

function deleteGame(id) {
  if (!confirm('Delete this game?')) return;
  saveGames(getGames().filter(g => g.id !== id));
  const lineups = getLineups();
  delete lineups[id];
  saveLineups(lineups);
  renderSchedule();
}

// ========== GAMES PAGE (Lineup Generation) ==========
let currentGameId = null;
let currentAbsent = [];
let currentBattery = {};
let currentLineup = null;
let currentBattingOrder = [];

function renderGamesList() {
  const games = getGames();
  const el = document.getElementById('gamesList');
  const detail = document.getElementById('gameDetail');
  detail.style.display = 'none';
  
  if (games.length === 0) {
    el.innerHTML = '<div class="card"><div class="empty-state"><h3>No games scheduled</h3><p>Go to the Schedule tab to add games first.</p></div></div>';
    return;
  }

  const rules = getRules();
  const lineups = getLineups();
  const sorted = [...games].sort((a,b) => (a.date + a.time).localeCompare(b.date + b.time));
  
  let html = '<div class="card"><h2>Select a Game</h2>';
  sorted.forEach(g => {
    const dugout = g.homeAway === 'home' ? rules.homeDugout : (rules.homeDugout === '3B' ? '1B' : '3B');
    const status = lineups[g.id] ? 'complete' : 'pending';
    const dateStr = g.date ? new Date(g.date + 'T00:00').toLocaleDateString('en-US', {weekday:'short', month:'short', day:'numeric'}) : '';
    const timeStr = g.time ? formatTime(g.time) : '';
    html += `<div class="game-card" onclick="openGame('${g.id}')">
      <div class="game-header">
        <h3>vs ${g.opponent}</h3>
        <span class="badge badge-${status}">${status === 'complete' ? 'Lineup Set' : 'Pending'}</span>
      </div>
      <div class="game-details">
        <span>üìÖ ${dateStr}</span>
        <span>‚è∞ ${timeStr}</span>
        <span>üìç ${g.location || 'TBD'}</span>
        <span class="dugout-indicator ${g.homeAway === 'home' ? 'dugout-home' : 'dugout-away'}">${g.homeAway === 'home' ? 'üè† Home' : 'üöó Away'} ‚Äî ${dugout} dugout</span>
      </div>
    </div>`;
  });
  html += '</div>';
  el.innerHTML = html;
}

function openGame(gameId) {
  currentGameId = gameId;
  const game = getGames().find(g => g.id === gameId);
  const rules = getRules();
  const players = getPlayers();
  const lineups = getLineups();
  const existingLineup = lineups[gameId];

  currentAbsent = existingLineup ? (existingLineup.absent || []) : [];
  currentBattery = existingLineup ? (existingLineup.battery || {}) : {};
  currentLineup = existingLineup ? existingLineup.assignments : null;
  currentBattingOrder = existingLineup ? (existingLineup.battingOrder || getBattingOrder()) : getBattingOrder();

  document.getElementById('gamesList').innerHTML = '';
  const detail = document.getElementById('gameDetail');
  detail.style.display = 'block';

  const dugout = game.homeAway === 'home' ? rules.homeDugout : (rules.homeDugout === '3B' ? '1B' : '3B');
  const dateStr = game.date ? new Date(game.date + 'T00:00').toLocaleDateString('en-US', {weekday:'long', month:'long', day:'numeric', year:'numeric'}) : '';
  const timeStr = game.time ? formatTime(game.time) : '';

  let html = `
    <div class="card">
      <button class="btn btn-outline btn-sm no-print" onclick="renderGamesList()" style="margin-bottom:12px;">‚Üê Back to Games</button>
      <h2>vs ${game.opponent}</h2>
      <div class="game-details" style="margin-bottom:16px;">
        <span>üìÖ ${dateStr}</span>
        <span>‚è∞ ${timeStr}</span>
        <span>üìç ${game.location || 'TBD'}</span>
        <span class="dugout-indicator ${game.homeAway === 'home' ? 'dugout-home' : 'dugout-away'}">${game.homeAway === 'home' ? 'üè† Home' : 'üöó Away'} ‚Äî ${dugout} dugout</span>
      </div>
    </div>

    <div class="card no-print">
      <h2>Step 1: Mark Absences</h2>
      <p style="color:var(--text-light);margin-bottom:12px;">Uncheck any players who will be absent.</p>
      <div id="absenceList"></div>
    </div>

    <div class="card no-print">
      <h2>Step 2: Battery Plan</h2>
      <p style="color:var(--text-light);margin-bottom:12px;">Assign pitcher and catcher for each inning.</p>
      <div id="batteryPlan"></div>
    </div>

    <div class="card no-print">
      <h2>Step 3: Batting Order</h2>
      <p style="color:var(--text-light);margin-bottom:12px;">Drag players to rearrange, then save when ready.</p>
      <div id="battingOrderList"></div>
      <div class="btn-group" style="margin-top:12px;">
        <button class="btn btn-accent" onclick="saveBattingOrderManual()">Save Batting Order</button>
        <button class="btn btn-outline" onclick="resetBattingOrder()">Reset</button>
      </div>
      <div id="battingOrderStatus" style="display:none;color:var(--accent);font-weight:600;margin-top:8px;"></div>
    </div>

    <div class="card no-print">
      <div class="btn-group">
        <button class="btn btn-accent" onclick="generateLineup()" style="font-size:1.1rem;padding:12px 32px;">‚ö° Generate Lineup</button>
        <button class="btn btn-outline" onclick="clearLineup()">Clear Lineup</button>
        <button class="btn btn-primary" onclick="openPrintView()">üñ® Print Lineup</button>
      </div>
    </div>

    <div id="lineupWarnings"></div>
    <div id="lineupOutput"></div>
  `;
  detail.innerHTML = html;
  renderAbsenceList();
  renderBatteryPlan();
  initBattingOrder();
  if (currentLineup) renderLineupOutput();
}

function renderAbsenceList() {
  const players = getPlayers().sort((a,b) => a.number - b.number);
  const el = document.getElementById('absenceList');
  let html = '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:8px;">';
  players.forEach(p => {
    const absent = currentAbsent.includes(p.id);
    html += `<div class="toggle-row">
      <input type="checkbox" id="abs_${p.id}" ${absent ? '' : 'checked'} onchange="toggleAbsence('${p.id}')">
      <label for="abs_${p.id}">#${p.number} ${p.firstName} ${p.lastName}</label>
    </div>`;
  });
  html += '</div>';
  el.innerHTML = html;
}

function toggleAbsence(playerId) {
  if (currentAbsent.includes(playerId)) {
    currentAbsent = currentAbsent.filter(id => id !== playerId);
  } else {
    currentAbsent.push(playerId);
  }
  initBattingOrder();
}

// ========== BATTING ORDER ==========
function initBattingOrder() {
  const players = getPlayers();
  const available = players.filter(p => !currentAbsent.includes(p.id));
  const availableIds = available.map(p => p.id);
  
  // Start from saved order, filter out absent players, append any new players
  let order = currentBattingOrder.filter(id => availableIds.includes(id));
  const missing = availableIds.filter(id => !order.includes(id));
  order = [...order, ...missing];
  currentBattingOrder = order;
  initBattingOrderSnapshot();
  renderBattingOrder();
}

let dragSrcIndex = null;

function renderBattingOrder() {
  const players = getPlayers();
  const playerMap = {};
  players.forEach(p => { playerMap[p.id] = p; });
  const el = document.getElementById('battingOrderList');
  
  let html = '<ul class="batting-list" id="battingListUl">';
  currentBattingOrder.forEach((id, i) => {
    const p = playerMap[id];
    if (!p) return;
    html += `<li class="batting-item" data-idx="${i}">
      <span class="batting-grip">‚ò∞</span>
      <span class="batting-order-num">${i + 1}</span>
      <span class="batting-name">#${p.number} ${p.firstName} ${p.lastName}</span>
    </li>`;
  });
  html += '</ul>';
  el.innerHTML = html;
  initTouchDrag();
}

// Touch-friendly drag reordering
let touchDragEl = null;
let touchStartY = 0;
let touchDragIdx = null;
let battingPlaceholder = null;

function initTouchDrag() {
  const list = document.getElementById('battingListUl');
  if (!list) return;
  const items = list.querySelectorAll('.batting-item');
  items.forEach(item => {
    item.addEventListener('touchstart', onTouchStart, { passive: false });
    item.addEventListener('touchmove', onTouchMove, { passive: false });
    item.addEventListener('touchend', onTouchEnd);
    // Keep mouse drag working for desktop
    item.setAttribute('draggable', 'true');
    item.addEventListener('dragstart', e => battingDragStart(e, parseInt(item.dataset.idx)));
    item.addEventListener('dragover', e => battingDragOver(e));
    item.addEventListener('dragenter', e => battingDragEnter(e));
    item.addEventListener('dragleave', e => battingDragLeave(e));
    item.addEventListener('drop', e => battingDrop(e, parseInt(item.dataset.idx)));
    item.addEventListener('dragend', e => battingDragEnd(e));
  });
}

function onTouchStart(e) {
  const grip = e.target.closest('.batting-grip');
  if (!grip) return;
  e.preventDefault();
  touchDragEl = e.target.closest('.batting-item');
  touchDragIdx = parseInt(touchDragEl.dataset.idx);
  touchStartY = e.touches[0].clientY;
  touchDragEl.classList.add('dragging');
}

function onTouchMove(e) {
  if (!touchDragEl) return;
  e.preventDefault();
  const touch = e.touches[0];
  const list = document.getElementById('battingListUl');
  const items = Array.from(list.querySelectorAll('.batting-item'));
  items.forEach(item => item.classList.remove('drag-over'));
  const target = document.elementFromPoint(touch.clientX, touch.clientY);
  if (target) {
    const targetItem = target.closest('.batting-item');
    if (targetItem && targetItem !== touchDragEl) {
      targetItem.classList.add('drag-over');
    }
  }
}

function onTouchEnd(e) {
  if (!touchDragEl) return;
  const touch = e.changedTouches[0];
  const target = document.elementFromPoint(touch.clientX, touch.clientY);
  const targetItem = target ? target.closest('.batting-item') : null;
  touchDragEl.classList.remove('dragging');
  document.querySelectorAll('.batting-item').forEach(el => el.classList.remove('drag-over'));
  
  if (targetItem && targetItem !== touchDragEl) {
    const targetIdx = parseInt(targetItem.dataset.idx);
    const moved = currentBattingOrder.splice(touchDragIdx, 1)[0];
    currentBattingOrder.splice(targetIdx, 0, moved);
    renderBattingOrder();
    showBattingUnsaved();
  }
  touchDragEl = null;
  touchDragIdx = null;
}

function battingDragStart(e, idx) {
  dragSrcIndex = idx;
  e.target.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
}

function battingDragOver(e) {
  e.preventDefault();
  e.dataTransfer.dropEffect = 'move';
}

function battingDragEnter(e) {
  const item = e.target.closest('.batting-item');
  if (item) item.classList.add('drag-over');
}

function battingDragLeave(e) {
  const item = e.target.closest('.batting-item');
  if (item) item.classList.remove('drag-over');
}

function battingDrop(e, targetIdx) {
  e.preventDefault();
  const item = e.target.closest('.batting-item');
  if (item) item.classList.remove('drag-over');
  if (dragSrcIndex === null || dragSrcIndex === targetIdx) return;
  
  const moved = currentBattingOrder.splice(dragSrcIndex, 1)[0];
  currentBattingOrder.splice(targetIdx, 0, moved);
  renderBattingOrder();
  showBattingUnsaved();
}

function battingDragEnd(e) {
  e.target.classList.remove('dragging');
  document.querySelectorAll('.batting-item').forEach(el => el.classList.remove('drag-over'));
  dragSrcIndex = null;
}

function moveBatter(idx, direction) {
  const newIdx = idx + direction;
  if (newIdx < 0 || newIdx >= currentBattingOrder.length) return;
  const temp = currentBattingOrder[idx];
  currentBattingOrder[idx] = currentBattingOrder[newIdx];
  currentBattingOrder[newIdx] = temp;
  renderBattingOrder();
  showBattingUnsaved();
}

let _savedBattingOrder = [];

function initBattingOrderSnapshot() {
  _savedBattingOrder = [...currentBattingOrder];
}

function showBattingUnsaved() {
  const el = document.getElementById('battingOrderStatus');
  if (el) { el.style.display = 'block'; el.textContent = 'Unsaved changes'; el.style.color = 'var(--warning)'; }
}

function saveBattingOrderManual() {
  saveBattingOrder(currentBattingOrder);
  _savedBattingOrder = [...currentBattingOrder];
  const el = document.getElementById('battingOrderStatus');
  if (el) { el.style.display = 'block'; el.textContent = 'Saved!'; el.style.color = 'var(--accent)'; }
  setTimeout(() => { if (el) el.style.display = 'none'; }, 2000);
}

function resetBattingOrder() {
  currentBattingOrder = [..._savedBattingOrder];
  renderBattingOrder();
  const el = document.getElementById('battingOrderStatus');
  if (el) el.style.display = 'none';
}

function renderBatteryPlan() {
  const rules = getRules();
  const players = getPlayers().sort((a,b) => a.number - b.number);
  const pitchers = players.filter(p => p.canPitch && !currentAbsent.includes(p.id));
  const catchers = players.filter(p => p.canCatch && !currentAbsent.includes(p.id));
  const el = document.getElementById('batteryPlan');

  let html = '<div class="battery-grid"><label></label>';
  for (let i = 1; i <= rules.innings; i++) html += `<label style="text-align:center;font-weight:700;">Inn ${i}</label>`;
  
  html += '<label>Pitcher</label>';
  for (let i = 1; i <= rules.innings; i++) {
    const val = (currentBattery['P'] && currentBattery['P'][i]) || '';
    html += `<select onchange="setBattery('P',${i},this.value)"><option value="">‚Äî</option>`;
    pitchers.forEach(p => { html += `<option value="${p.id}" ${val === p.id ? 'selected' : ''}>#${p.number} ${p.firstName}</option>`; });
    html += '</select>';
  }

  html += '<label>Catcher</label>';
  for (let i = 1; i <= rules.innings; i++) {
    const val = (currentBattery['C'] && currentBattery['C'][i]) || '';
    html += `<select onchange="setBattery('C',${i},this.value)"><option value="">‚Äî</option>`;
    catchers.forEach(p => { html += `<option value="${p.id}" ${val === p.id ? 'selected' : ''}>#${p.number} ${p.firstName}</option>`; });
    html += '</select>';
  }
  html += '</div>';
  el.innerHTML = html;
}

function setBattery(pos, inning, playerId) {
  if (!currentBattery[pos]) currentBattery[pos] = {};
  currentBattery[pos][inning] = playerId || null;
}

// ========== LINEUP GENERATION ENGINE ==========
// Priority: balanced every inning, strongest at start/end, infield always strong, constraints guaranteed
function generateLineup() {
  const rules = getRules();
  const allPlayers = getPlayers();
  const available = allPlayers.filter(p => !currentAbsent.includes(p.id));
  
  if (available.length < rules.fielders) {
    alert(`Need at least ${rules.fielders} available players. Only ${available.length} present.`);
    return;
  }

  const innings = rules.innings;
  const numFielders = rules.fielders;
  const numBench = available.length - numFielders;
  const minInfield = rules.minInfield;
  const playerIds = available.map(p => p.id);
  const N = playerIds.length;

  // Build position suitability scores
  const posScores = {};
  available.forEach(p => {
    posScores[p.id] = {};
    POSITIONS.forEach(pos => { posScores[p.id][pos] = calcPositionScore(p, pos, rules); });
  });

  // Compute overall player strength (sum of best position scores)
  const playerStrength = {};
  available.forEach(p => {
    const scores = POSITIONS.map(pos => posScores[p.id][pos]);
    scores.sort((a, b) => b - a);
    // Weight by top 3 position scores ‚Äî represents how valuable they are on the field
    playerStrength[p.id] = scores[0] * 3 + scores[1] * 2 + scores[2];
  });

  // Rank players strongest to weakest
  const rankedByStrength = [...playerIds].sort((a, b) => playerStrength[b] - playerStrength[a]);

  // ---- Battery locks ----
  const grid = {};
  for (let inn = 1; inn <= innings; inn++) {
    grid[inn] = {};
    const pitcher = currentBattery['P'] && currentBattery['P'][inn];
    const catcher = currentBattery['C'] && currentBattery['C'][inn];
    if (pitcher) grid[inn]['P'] = pitcher;
    if (catcher) grid[inn]['C'] = catcher;
  }

  // ---- PHASE 1: Schedule bench slots ----
  // Fair: each player benches floor or ceil(totalBenchSlots/N) times
  // Priority: weaker players bench in innings 1 and last (so they're on field in middle)
  // Stronger players bench in middle innings (so they're on field at start and end)
  const totalBenchSlots = numBench * innings;
  const baseBench = Math.floor(totalBenchSlots / N);
  const extraBench = totalBenchSlots % N;

  // Weaker players get the extra bench slot if needed
  const targetBench = {};
  rankedByStrength.forEach((id, i) => {
    // Strongest first in array; weakest at end get extra bench
    targetBench[id] = baseBench + (i >= N - extraBench ? 1 : 0);
  });

  // Inning desirability: innings 1 and last are most important to have strong lineup
  // Middle innings are where we prefer strong players to bench
  const midInnings = [];
  const edgeInnings = [];
  for (let i = 1; i <= innings; i++) {
    if (i === 1 || i === innings) edgeInnings.push(i);
    else midInnings.push(i);
  }
  // Preferred bench order: middle innings first, edges last
  // Within middle, prefer the most central inning
  const mid = (innings + 1) / 2;
  const benchInningPriority = [...midInnings].sort((a, b) => Math.abs(a - mid) - Math.abs(b - mid));
  benchInningPriority.push(...edgeInnings);

  const benchGrid = {}; // benchGrid[inn] = Set of playerIds
  for (let inn = 1; inn <= innings; inn++) benchGrid[inn] = new Set();

  // Schedule bench: strong players bench in middle, weak players bench at edges
  // Process strong players first ‚Äî they get preferred (middle) bench innings
  rankedByStrength.forEach(id => {
    let needed = targetBench[id];
    if (needed <= 0) return;

    // Can't bench in innings where battery-locked
    const available_innings = benchInningPriority.filter(inn => {
      if (grid[inn]['P'] === id || grid[inn]['C'] === id) return false;
      if (benchGrid[inn].size >= numBench) return false;
      return true;
    });

    for (let i = 0; i < available_innings.length && needed > 0; i++) {
      const inn = available_innings[i];
      benchGrid[inn].add(id);
      needed--;
    }
  });

  // ---- PHASE 2: For each inning, determine who fields and who's benched ----
  const fieldersPerInning = {};
  const benchPerInning = {};
  for (let inn = 1; inn <= innings; inn++) {
    benchPerInning[inn] = [...benchGrid[inn]];
    fieldersPerInning[inn] = playerIds.filter(id => !benchGrid[inn].has(id));
  }

  // ---- PHASE 3: Guarantee infield minimums ----
  // Track infield assignments
  const infieldCount = {};
  playerIds.forEach(id => { infieldCount[id] = 0; });

  // For each inning, we'll mark which fielders MUST play infield
  const mustInfield = {}; // mustInfield[inn] = Set of playerIds
  for (let inn = 1; inn <= innings; inn++) mustInfield[inn] = new Set();

  // Determine who needs infield innings and schedule them
  // Process players with fewest fielding innings first (hardest to place)
  const fieldingInnings = {};
  playerIds.forEach(id => {
    fieldingInnings[id] = [];
    for (let inn = 1; inn <= innings; inn++) {
      if (!benchGrid[inn].has(id) && grid[inn]['P'] !== id && grid[inn]['C'] !== id) {
        fieldingInnings[id].push(inn);
      }
    }
  });

  // Sort: players with fewest available fielding innings first (they're hardest to satisfy)
  const infieldScheduleOrder = [...playerIds].sort((a, b) => fieldingInnings[a].length - fieldingInnings[b].length);

  infieldScheduleOrder.forEach(id => {
    let needed = minInfield - infieldCount[id];
    if (needed <= 0) return;

    // Pick innings where this player is fielding and infield isn't full
    const candidates = fieldingInnings[id].filter(inn => mustInfield[inn].size < 4);
    
    // Prefer middle innings for weaker players' infield (strong players around them)
    // Prefer edge innings for strong players' infield
    const isStrong = playerStrength[id] >= playerStrength[rankedByStrength[Math.floor(N/2)]];
    if (isStrong) {
      // Strong players: prefer edge innings for infield (strengthens start/end)
      candidates.sort((a, b) => {
        const aDist = Math.min(a, innings + 1 - a);
        const bDist = Math.min(b, innings + 1 - b);
        return aDist - bDist; // edges first
      });
    } else {
      // Weak players: prefer middle innings for infield (surrounded by strong)
      candidates.sort((a, b) => {
        const aDist = Math.abs(a - mid);
        const bDist = Math.abs(b - mid);
        return aDist - bDist; // middle first
      });
    }

    for (let i = 0; i < candidates.length && needed > 0; i++) {
      const inn = candidates[i];
      mustInfield[inn].add(id);
      infieldCount[id]++;
      needed--;
    }
  });

  // ---- PHASE 4: Assign specific positions per inning ----
  for (let inn = 1; inn <= innings; inn++) {
    const fielders = fieldersPerInning[inn];
    const assigned = new Set(Object.values(grid[inn]));
    
    const positionsToFill = POSITIONS.filter(pos => !grid[inn][pos]);
    const ifPositions = positionsToFill.filter(p => INFIELD.includes(p));
    const ofPositions = positionsToFill.filter(p => !INFIELD.includes(p));

    // Players who must play infield this inning
    const mustIF = fielders.filter(id => mustInfield[inn].has(id) && !assigned.has(id));
    // Players free to go anywhere
    const freeFielders = fielders.filter(id => !mustInfield[inn].has(id) && !assigned.has(id));

    // Assign must-infield players to infield positions by best fit
    const ifAssign = bestMatch(mustIF, ifPositions, posScores);
    ifAssign.forEach(([id, pos]) => { grid[inn][pos] = id; assigned.add(id); });

    // Fill remaining infield with strongest available free fielders
    const remainIF = ifPositions.filter(p => !grid[inn][p]);
    if (remainIF.length > 0) {
      // Sort free fielders by infield strength descending
      const ifCandidates = freeFielders.filter(id => !assigned.has(id));
      const ifFill = bestMatch(ifCandidates, remainIF, posScores);
      ifFill.forEach(([id, pos]) => { grid[inn][pos] = id; assigned.add(id); });
    }

    // Fill outfield positions
    const remainOF = ofPositions.filter(p => !grid[inn][p]);
    const ofCandidates = [...freeFielders, ...mustIF].filter(id => !assigned.has(id));
    if (remainOF.length > 0) {
      const ofFill = bestMatch(ofCandidates, remainOF, posScores);
      ofFill.forEach(([id, pos]) => { grid[inn][pos] = id; assigned.add(id); });
    }

    // Catch-all: fill any remaining spots
    const stillOpen = POSITIONS.filter(p => !grid[inn][p]);
    const stillFree = fielders.filter(id => !assigned.has(id));
    stillOpen.forEach((pos, i) => {
      if (i < stillFree.length) { grid[inn][pos] = stillFree[i]; assigned.add(stillFree[i]); }
    });

    // Bench
    grid[inn]['BENCH'] = benchPerInning[inn];
  }

  // ---- PHASE 5: Repair pass ‚Äî verify all constraints ----
  const actualInfield = {};
  const actualBench = {};
  playerIds.forEach(id => { actualInfield[id] = 0; actualBench[id] = 0; });
  for (let inn = 1; inn <= innings; inn++) {
    INFIELD.forEach(pos => { if (grid[inn][pos]) actualInfield[grid[inn][pos]]++; });
    (grid[inn]['BENCH'] || []).forEach(id => actualBench[id]++);
  }

  // Fix infield shortfalls via swaps
  for (let pass = 0; pass < 20; pass++) {
    let fixed = false;
    
    playerIds.forEach(shortId => {
      if (actualInfield[shortId] >= minInfield) return;
      
      for (let inn = 1; inn <= innings; inn++) {
        if (actualInfield[shortId] >= minInfield) return;
        
        // Is this player fielding (non-infield) this inning?
        const myEntry = Object.entries(grid[inn]).find(([pos, pid]) => pid === shortId && pos !== 'BENCH');
        if (!myEntry) continue;
        const [myPos] = myEntry;
        if (INFIELD.includes(myPos) || myPos === 'P' || myPos === 'C') continue;
        
        // Swap with an infielder who has surplus
        for (const ifPos of INFIELD) {
          const occupant = grid[inn][ifPos];
          if (!occupant || isBatteryLocked(inn, occupant)) continue;
          if (actualInfield[occupant] <= minInfield) continue;
          
          grid[inn][ifPos] = shortId;
          grid[inn][myPos] = occupant;
          actualInfield[shortId]++;
          actualInfield[occupant]--;
          fixed = true;
          break;
        }
      }
      
      // Try bench-swap if still short
      if (actualInfield[shortId] >= minInfield) return;
      for (let inn = 1; inn <= innings; inn++) {
        if (actualInfield[shortId] >= minInfield) return;
        if (!(grid[inn]['BENCH'] || []).includes(shortId)) continue;
        
        for (const ofPos of ['LF', 'CF', 'RF']) {
          const ofOccupant = grid[inn][ofPos];
          if (!ofOccupant || isBatteryLocked(inn, ofOccupant)) continue;
          
          for (const ifPos of INFIELD) {
            const ifOccupant = grid[inn][ifPos];
            if (!ifOccupant || isBatteryLocked(inn, ifOccupant)) continue;
            if (actualInfield[ifOccupant] <= minInfield) continue;
            
            // Three-way: shortId‚ÜíifPos, ifOccupant‚ÜíofPos, ofOccupant‚Üíbench
            grid[inn][ifPos] = shortId;
            grid[inn][ofPos] = ifOccupant;
            const bi = grid[inn]['BENCH'].indexOf(shortId);
            grid[inn]['BENCH'][bi] = ofOccupant;
            actualInfield[shortId]++;
            actualInfield[ifOccupant]--;
            actualBench[shortId]--;
            actualBench[ofOccupant]++;
            fixed = true;
            break;
          }
          if (actualInfield[shortId] >= minInfield) break;
        }
      }
    });
    
    if (!fixed) break;
  }

  // Fix bench fairness (max-min ‚â§ 1)
  for (let pass = 0; pass < 20; pass++) {
    const maxB = Math.max(...playerIds.map(id => actualBench[id]));
    const minB = Math.min(...playerIds.map(id => actualBench[id]));
    if (maxB - minB <= 1) break;
    
    let swapped = false;
    for (let inn = 1; inn <= innings; inn++) {
      const bench = grid[inn]['BENCH'] || [];
      for (let bi = 0; bi < bench.length; bi++) {
        const benchId = bench[bi];
        if (actualBench[benchId] <= minB + 1) continue;
        
        for (const pos of ['LF', 'CF', 'RF']) {
          const fielderId = grid[inn][pos];
          if (!fielderId || isBatteryLocked(inn, fielderId)) continue;
          if (actualBench[fielderId] >= actualBench[benchId] - 1) continue;
          // Don't break fielderId's infield count
          if (INFIELD.includes(pos) && actualInfield[fielderId] <= minInfield) continue;
          
          grid[inn][pos] = benchId;
          grid[inn]['BENCH'][bi] = fielderId;
          actualBench[benchId]--;
          actualBench[fielderId]++;
          swapped = true;
          break;
        }
      }
    }
    if (!swapped) break;
  }

  currentLineup = grid;
  
  // Save
  const lineups = getLineups();
  lineups[currentGameId] = {
    assignments: currentLineup,
    absent: [...currentAbsent],
    battery: JSON.parse(JSON.stringify(currentBattery)),
    battingOrder: [...currentBattingOrder],
    generatedAt: new Date().toISOString()
  };
  saveLineups(lineups);
  saveBattingOrder(currentBattingOrder);
  
  renderLineupOutput();
}

function isBatteryLocked(inn, playerId) {
  return (currentBattery['P'] && currentBattery['P'][inn] === playerId) ||
         (currentBattery['C'] && currentBattery['C'][inn] === playerId);
}

// Greedy best-fit matching of players to positions by score
function bestMatch(playerList, posList, scores) {
  const result = [];
  const usedPlayers = new Set();
  const usedPositions = new Set();
  
  const pairs = [];
  playerList.forEach(id => {
    posList.forEach(pos => {
      pairs.push({ id, pos, score: scores[id] ? scores[id][pos] || 0 : 0 });
    });
  });
  pairs.sort((a, b) => b.score - a.score);
  
  pairs.forEach(({ id, pos }) => {
    if (usedPlayers.has(id) || usedPositions.has(pos)) return;
    result.push([id, pos]);
    usedPlayers.add(id);
    usedPositions.add(pos);
  });
  
  return result;
}

function calcPositionScore(player, pos, rules) {
  const s = player.skills || {};
  const get = (attr) => s[attr] || 1;
  
  switch(pos) {
    case 'P': return player.canPitch ? 5 : 0;
    case 'C': return player.canCatch ? 5 : 0;
    case 'SS': return (get('Fielding Ability') + get('Arm Accuracy') + get('Arm Strength') + get('Agility') + get('Baseball IQ')) / 5 * 1.2;
    case '2B': return (get('Fielding Ability') + get('Agility') + get('Infield Catching Ability') + get('Baseball IQ')) / 4;
    case '1B': return (get('Infield Catching Ability') + get('Fielding Ability')) / 2 * 1.1;
    case '3B': return (get('Fielding Ability') + get('Arm Strength') + get('Arm Accuracy') + get('Infield Catching Ability')) / 4;
    case 'LF': return (get('Outfield Ability') + get('Fielding Ability') + get('Arm Strength')) / 3;
    case 'CF': return (get('Outfield Ability') + get('Agility') + get('Fielding Ability') + get('Baseball IQ')) / 4 * 1.1;
    case 'RF': return (get('Outfield Ability') + get('Arm Strength') + get('Fielding Ability')) / 3;
    default: return 1;
  }
}

function clearLineup() {
  currentLineup = null;
  const lineups = getLineups();
  delete lineups[currentGameId];
  saveLineups(lineups);
  document.getElementById('lineupOutput').innerHTML = '';
  document.getElementById('lineupWarnings').innerHTML = '';
}

function openPrintView() {
  if (!currentLineup) { alert('Generate a lineup first.'); return; }
  const rules = getRules();
  const game = getGames().find(g => g.id === currentGameId);
  const allPlayers = getPlayers();
  const available = allPlayers.filter(p => !currentAbsent.includes(p.id));
  const playerMap = {};
  allPlayers.forEach(p => { playerMap[p.id] = p; });

  const dugout = game.homeAway === 'home' ? rules.homeDugout : (rules.homeDugout === '3B' ? '1B' : '3B');
  const dateStr = game.date ? new Date(game.date + 'T00:00').toLocaleDateString('en-US', {weekday:'long', month:'long', day:'numeric', year:'numeric'}) : '';
  const timeStr = game.time ? formatTime(game.time) : '';

  const fieldSVG = `<svg viewBox="0 0 520 480" xmlns="http://www.w3.org/2000/svg" style="width:100%;height:100%;">
    <path d="M 260 420 L 10 110 A 340 340 0 0 1 510 110 Z" fill="#4a8c3f" stroke="#3d7534" stroke-width="1"/>
    <path d="M 260 375 L 120 230 L 260 145 L 400 230 Z" fill="#c4956a" stroke="#a67c52" stroke-width="1"/>
    <circle cx="260" cy="265" r="55" fill="#4a8c3f"/>
    <circle cx="260" cy="285" r="14" fill="#c4956a" stroke="#a67c52" stroke-width="1"/>
    <circle cx="260" cy="285" r="3" fill="#fff"/>
    <line x1="260" y1="375" x2="400" y2="250" stroke="#fff" stroke-width="2" opacity="0.6"/>
    <line x1="400" y1="250" x2="260" y2="145" stroke="#fff" stroke-width="2" opacity="0.6"/>
    <line x1="260" y1="145" x2="120" y2="250" stroke="#fff" stroke-width="2" opacity="0.6"/>
    <line x1="120" y1="250" x2="260" y2="375" stroke="#fff" stroke-width="2" opacity="0.6"/>
    <rect x="254" y="369" width="12" height="12" fill="#fff" transform="rotate(45 260 375)"/>
    <rect x="394" y="244" width="11" height="11" fill="#fff" transform="rotate(45 400 250)"/>
    <rect x="255" y="139" width="11" height="11" fill="#fff" transform="rotate(45 260 145)"/>
    <rect x="115" y="244" width="11" height="11" fill="#fff" transform="rotate(45 120 250)"/>
    <line x1="260" y1="420" x2="0" y2="90" stroke="#fff" stroke-width="2" opacity="0.4"/>
    <line x1="260" y1="420" x2="520" y2="90" stroke="#fff" stroke-width="2" opacity="0.4"/>
    <rect x="243" y="400" width="34" height="44" rx="3" fill="#c4956a" stroke="#a67c52" stroke-width="1"/>
    <path d="M 10 110 A 340 340 0 0 1 510 110" fill="none" stroke="#2c3e50" stroke-width="3" opacity="0.3"/>
  </svg>`;

  // Position coordinates for print (relative to 420x380 container)
  const printPositions = {
    P:  { left: '185px', top: '210px' },
    C:  { left: '185px', top: '320px' },
    '1B': { left: '300px', top: '205px' },
    '2B': { left: '248px', top: '118px' },
    SS: { left: '128px', top: '118px' },
    '3B': { left: '68px',  top: '205px' },
    LF: { left: '24px',  top: '48px' },
    CF: { left: '185px', top: '10px' },
    RF: { left: '346px', top: '48px' }
  };

  const gameHeader = `
    <div style="text-align:center;margin-bottom:8px;">
      <h1 style="margin:0;font-size:1.5rem;">LineupIQ</h1>
      <h2 style="margin:4px 0;font-size:1.2rem;">vs ${game.opponent}</h2>
      <div style="font-size:0.9rem;color:#666;">
        ${dateStr} &bull; ${timeStr} &bull; ${game.location || 'TBD'} &bull; 
        ${game.homeAway === 'home' ? 'Home' : 'Away'} &mdash; ${dugout} dugout
      </div>
    </div>`;

  // Build grid page
  let gridHtml = `<table style="width:100%;border-collapse:collapse;font-size:1rem;color:#000;">
    <thead><tr><th style="text-align:left;border-bottom:2px solid #333;padding:6px 8px;font-size:1rem;">Player</th>`;
  for (let i = 1; i <= rules.innings; i++) gridHtml += `<th style="text-align:center;border:2px solid #333;padding:6px 8px;background:#e8f0fe;font-size:1rem;">Inn ${i}</th>`;
  gridHtml += `<th style="text-align:center;border-bottom:2px solid #333;padding:6px 8px;font-size:1rem;">IF</th>
    <th style="text-align:center;border-bottom:2px solid #333;padding:6px 8px;font-size:1rem;">BN</th></tr></thead><tbody>`;

  available.sort((a,b) => a.number - b.number).forEach(p => {
    let ifCount = 0, benchCount = 0;
    gridHtml += `<tr><td style="border-bottom:1px solid #999;padding:6px 8px;font-weight:700;font-size:0.95rem;">#${p.number} ${p.firstName} ${p.lastName}</td>`;
    for (let inn = 1; inn <= rules.innings; inn++) {
      const pos = Object.entries(currentLineup[inn]).find(([pos, pid]) => pid === p.id && pos !== 'BENCH');
      const isBench = (currentLineup[inn]['BENCH'] || []).includes(p.id);
      if (pos) {
        const [position] = pos;
        if (INFIELD.includes(position)) ifCount++;
        gridHtml += `<td style="text-align:center;border-left:2px solid #333;border-right:2px solid #333;border-bottom:1px solid #999;padding:6px 8px;font-weight:600;font-size:0.95rem;${INFIELD.includes(position)?'background:#e8f4fd;':''}">${position}</td>`;
      } else if (isBench) {
        benchCount++;
        gridHtml += '<td style="text-align:center;border-left:2px solid #333;border-right:2px solid #333;border-bottom:1px solid #999;padding:6px 8px;font-weight:600;font-size:0.95rem;background:#fef9e7;">BN</td>';
      } else {
        gridHtml += '<td style="text-align:center;border-left:2px solid #333;border-right:2px solid #333;border-bottom:1px solid #999;padding:6px 8px;font-size:0.95rem;">-</td>';
      }
    }
    gridHtml += `<td style="text-align:center;border-bottom:1px solid #999;padding:6px 8px;font-weight:700;font-size:0.95rem;">${ifCount}</td>`;
    gridHtml += `<td style="text-align:center;border-bottom:1px solid #999;padding:6px 8px;font-weight:600;font-size:0.95rem;">${benchCount}</td></tr>`;
  });
  // Close the box on the bottom of inning columns
  gridHtml += `<tr><td style="border:none;"></td>`;
  for (let i = 1; i <= rules.innings; i++) gridHtml += `<td style="border-top:2px solid #333;padding:0;"></td>`;
  gridHtml += `<td style="border:none;"></td><td style="border:none;"></td></tr>`;
  gridHtml += '</tbody></table>';

  // Build field pages
  let fieldPages = '';
  for (let inn = 1; inn <= rules.innings; inn++) {
    fieldPages += `<div style="page-break-before:always;padding:20px;">`;
    fieldPages += gameHeader;
    fieldPages += `<h3 style="text-align:center;font-size:1.1rem;margin:12px 0;">Inning ${inn}</h3>`;
    fieldPages += `<div style="position:relative;width:420px;height:380px;margin:0 auto;">`;
    fieldPages += fieldSVG.replace('width:100%;height:100%', 'width:420px;height:380px');
    
    POSITIONS.forEach(pos => {
      const pid = currentLineup[inn][pos];
      const player = pid ? playerMap[pid] : null;
      const name = player ? `#${player.number} ${player.firstName}` : '‚Äî';
      const coords = printPositions[pos];
      fieldPages += `<div style="position:absolute;left:${coords.left};top:${coords.top};text-align:center;">
        <div style="width:52px;height:52px;border-radius:50%;background:#fff;border:2px solid #1a5276;display:flex;flex-direction:column;align-items:center;justify-content:center;box-shadow:0 1px 3px rgba(0,0,0,0.2);">
          <span style="font-size:0.55rem;font-weight:700;color:#1a5276;text-transform:uppercase;">${pos}</span>
          <span style="font-size:0.65rem;font-weight:600;">${name}</span>
        </div>
      </div>`;
    });
    fieldPages += '</div>';

    const bench = currentLineup[inn]['BENCH'] || [];
    if (bench.length > 0) {
      fieldPages += '<div style="text-align:center;margin-top:12px;"><strong>Bench:</strong> ';
      bench.forEach(pid => {
        const p = playerMap[pid];
        if (p) fieldPages += `<span style="background:#fef9e7;padding:2px 10px;border-radius:12px;font-size:0.8rem;font-weight:600;margin:0 4px;">#${p.number} ${p.firstName}</span>`;
      });
      fieldPages += '</div>';
    }
    fieldPages += '</div>';
  }

  // Build batting order for print
  let battingHtml = '';
  if (currentBattingOrder.length > 0) {
    battingHtml = `<h3 style="text-align:center;margin:16px 0 8px;">Batting Order</h3>
      <table style="width:auto;margin:0 auto;border-collapse:collapse;font-size:0.85rem;">
      <thead><tr><th style="border-bottom:2px solid #333;padding:4px 12px;text-align:center;">#</th>
      <th style="border-bottom:2px solid #333;padding:4px 12px;text-align:left;">Player</th></tr></thead><tbody>`;
    currentBattingOrder.forEach((id, i) => {
      const p = playerMap[id];
      if (!p) return;
      battingHtml += `<tr><td style="border-bottom:1px solid #ddd;padding:4px 12px;text-align:center;font-weight:700;">${i + 1}</td>
        <td style="border-bottom:1px solid #ddd;padding:4px 12px;">#${p.number} ${p.firstName} ${p.lastName}</td></tr>`;
    });
    battingHtml += '</tbody></table>';
  }

  // Open print window
  const printWindow = window.open('', '_blank');
  printWindow.document.write(`<!DOCTYPE html><html><head><title>LineupIQ - vs ${game.opponent}</title>
    <style>
      * { box-sizing: border-box; margin: 0; padding: 0; }
      body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
      .print-btn { display: block; margin: 16px auto; padding: 12px 32px; font-size: 1rem; font-weight: 600; background: #1a5276; color: #fff; border: none; border-radius: 6px; cursor: pointer; }
      .print-btn:hover { background: #2980b9; }
      @media print {
        body { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
        .no-print { display: none !important; }
      }
      @page { margin: 0.5in; }
    </style>
  </head><body>
    <div class="no-print" style="text-align:center;padding:12px;background:#f5f6fa;border-bottom:1px solid #ddd;">
      <button class="print-btn" onclick="window.print()">üñ® Print / Save as PDF</button>
    </div>
    <div style="padding:20px;">
      ${gameHeader}
      <h3 style="text-align:center;margin:12px 0;">Lineup Grid</h3>
      ${gridHtml}
    </div>
    <div style="page-break-before:always;padding:20px;">
      ${gameHeader}
      ${battingHtml}
    </div>
    ${fieldPages}
  </body></html>`);
  printWindow.document.close();
}

// ========== LINEUP OUTPUT (Grid + Diamond) ==========
function renderLineupOutput() {
  if (!currentLineup) return;
  const rules = getRules();
  const allPlayers = getPlayers();
  const available = allPlayers.filter(p => !currentAbsent.includes(p.id));
  const playerMap = {};
  allPlayers.forEach(p => { playerMap[p.id] = p; });

  // Validate and show warnings
  renderWarnings(available, playerMap, rules);

  let html = '<div class="card"><h2>Generated Lineup</h2>';
  
  // Grid view
  html += '<div class="lineup-grid"><table><thead><tr><th>Player</th>';
  for (let i = 1; i <= rules.innings; i++) html += `<th style="text-align:center;border:2px solid #333;background:#e8f0fe;">Inn ${i}</th>`;
  html += '<th>IF Inn</th><th>Bench</th></tr></thead><tbody>';

  available.sort((a,b) => a.number - b.number).forEach(p => {
    let ifCount = 0, benchCount = 0;
    html += `<tr><td style="font-weight:700;">#${p.number} ${p.firstName} ${p.lastName}</td>`;
    for (let inn = 1; inn <= rules.innings; inn++) {
      const pos = Object.entries(currentLineup[inn]).find(([pos, pid]) => pid === p.id && pos !== 'BENCH');
      const isBench = (currentLineup[inn]['BENCH'] || []).includes(p.id);
      if (pos) {
        const [position] = pos;
        const isInfield = INFIELD.includes(position);
        if (isInfield) ifCount++;
        html += `<td style="text-align:center;font-weight:600;border-left:2px solid #333;border-right:2px solid #333;${isInfield ? 'background:#ebf5fb;' : ''}">${position}</td>`;
      } else if (isBench) {
        benchCount++;
        html += '<td style="text-align:center;font-weight:600;border-left:2px solid #333;border-right:2px solid #333;" class="bench-cell">BN</td>';
      } else {
        html += '<td style="text-align:center;border-left:2px solid #333;border-right:2px solid #333;">-</td>';
      }
    }
    const ifStyle = ifCount < rules.minInfield ? 'color:var(--danger);font-weight:700;' : 'color:var(--accent);font-weight:700;';
    html += `<td style="${ifStyle}">${ifCount}</td>`;
    html += `<td style="font-weight:600;">${benchCount}</td>`;
    html += '</tr>';
  });
  html += '</tbody></table></div>';

  // Diamond views per inning
  html += '<div style="margin-top:24px;"><h3>Field View</h3>';
  html += '<div class="inning-tabs" id="inningTabs">';
  for (let i = 1; i <= rules.innings; i++) {
    html += `<div class="inning-tab ${i===1?'active':''}" onclick="showInning(${i})">${i}</div>`;
  }
  html += '</div>';
  
  for (let inn = 1; inn <= rules.innings; inn++) {
    html += `<div class="inning-view" id="inningView_${inn}" style="${inn===1?'':'display:none;'}">`;
    html += '<div class="field-container">';
    // SVG baseball field
    html += `<svg class="field-svg" viewBox="0 0 520 480" xmlns="http://www.w3.org/2000/svg">
      <!-- Outfield grass -->
      <path d="M 260 420 L 10 110 A 340 340 0 0 1 510 110 Z" fill="#4a8c3f" stroke="#3d7534" stroke-width="1"/>
      <!-- Infield dirt -->
      <path d="M 260 375 L 120 230 L 260 145 L 400 230 Z" fill="#c4956a" stroke="#a67c52" stroke-width="1"/>
      <!-- Infield grass (between mound and bases) -->
      <circle cx="260" cy="265" r="55" fill="#4a8c3f"/>
      <!-- Pitcher mound -->
      <circle cx="260" cy="285" r="14" fill="#c4956a" stroke="#a67c52" stroke-width="1"/>
      <circle cx="260" cy="285" r="3" fill="#fff"/>
      <!-- Base paths -->
      <line x1="260" y1="375" x2="400" y2="250" stroke="#fff" stroke-width="2" opacity="0.6"/>
      <line x1="400" y1="250" x2="260" y2="145" stroke="#fff" stroke-width="2" opacity="0.6"/>
      <line x1="260" y1="145" x2="120" y2="250" stroke="#fff" stroke-width="2" opacity="0.6"/>
      <line x1="120" y1="250" x2="260" y2="375" stroke="#fff" stroke-width="2" opacity="0.6"/>
      <!-- Bases -->
      <rect x="254" y="369" width="12" height="12" fill="#fff" transform="rotate(45 260 375)"/>
      <rect x="394" y="244" width="11" height="11" fill="#fff" transform="rotate(45 400 250)"/>
      <rect x="255" y="139" width="11" height="11" fill="#fff" transform="rotate(45 260 145)"/>
      <rect x="115" y="244" width="11" height="11" fill="#fff" transform="rotate(45 120 250)"/>
      <!-- Foul lines -->
      <line x1="260" y1="420" x2="0" y2="90" stroke="#fff" stroke-width="2" opacity="0.4"/>
      <line x1="260" y1="420" x2="520" y2="90" stroke="#fff" stroke-width="2" opacity="0.4"/>
      <!-- Batter's box area -->
      <rect x="243" y="400" width="34" height="44" rx="3" fill="#c4956a" stroke="#a67c52" stroke-width="1"/>
      <!-- Outfield fence arc -->
      <path d="M 10 110 A 340 340 0 0 1 510 110" fill="none" stroke="#2c3e50" stroke-width="3" opacity="0.3"/>
    </svg>`;
    // Player position labels overlaid
    POSITIONS.forEach(pos => {
      const pid = currentLineup[inn][pos];
      const player = pid ? playerMap[pid] : null;
      const name = player ? `#${player.number} ${player.firstName}` : '‚Äî';
      html += `<div class="field-pos fpos-${pos}"><div class="pos-dot"><span class="pos-label">${pos}</span><span class="pos-player">${name}</span></div></div>`;
    });
    html += '</div>';
    
    const bench = currentLineup[inn]['BENCH'] || [];
    if (bench.length > 0) {
      html += '<div style="text-align:center;margin-top:8px;"><strong>Bench:</strong> <div class="bench-list" style="justify-content:center;">';
      bench.forEach(pid => {
        const p = playerMap[pid];
        if (p) html += `<span class="bench-player">#${p.number} ${p.firstName}</span>`;
      });
      html += '</div></div>';
    }
    html += '</div>';
  }
  html += '</div></div>';

  // Add print button at bottom of lineup
  html += `<div class="card no-print" style="text-align:center;">
    <button class="btn btn-primary" onclick="openPrintView()" style="font-size:1.1rem;padding:12px 32px;">üñ® Print Full Game Lineup</button>
    <p style="color:var(--text-light);margin-top:8px;font-size:0.85rem;">Opens printable view: Page 1 = grid + batting order, Pages 2-7 = field diagrams</p>
  </div>`;

  document.getElementById('lineupOutput').innerHTML = html;
}

function showInning(inn) {
  document.querySelectorAll('.inning-tab').forEach((t, i) => t.classList.toggle('active', i + 1 === inn));
  document.querySelectorAll('.inning-view').forEach(v => v.style.display = 'none');
  const view = document.getElementById('inningView_' + inn);
  if (view) view.style.display = '';
}

function renderWarnings(available, playerMap, rules) {
  const el = document.getElementById('lineupWarnings');
  let html = '';
  const errors = [];
  const warnings = [];

  // Check infield minimums
  available.forEach(p => {
    let ifCount = 0;
    for (let inn = 1; inn <= rules.innings; inn++) {
      const pos = Object.entries(currentLineup[inn]).find(([pos, pid]) => pid === p.id && pos !== 'BENCH');
      if (pos && INFIELD.includes(pos[0])) ifCount++;
    }
    if (ifCount < rules.minInfield) {
      errors.push(`#${p.number} ${p.firstName} ${p.lastName} has only ${ifCount} infield inning(s) (min: ${rules.minInfield})`);
    }
  });

  // Check bench fairness
  const benchCounts = available.map(p => {
    let bc = 0;
    for (let inn = 1; inn <= rules.innings; inn++) {
      if ((currentLineup[inn]['BENCH'] || []).includes(p.id)) bc++;
    }
    return { player: p, count: bc };
  });
  const maxB = Math.max(...benchCounts.map(x => x.count));
  const minB = Math.min(...benchCounts.map(x => x.count));
  if (maxB - minB > 1) {
    const over = benchCounts.filter(x => x.count > minB + 1);
    over.forEach(x => {
      errors.push(`#${x.player.number} ${x.player.firstName} benched ${x.count} times (others as few as ${minB})`);
    });
  }

  // Pitcher/catcher advisory warnings
  if (currentBattery['C']) {
    const catcherInnings = {};
    Object.values(currentBattery['C']).forEach(pid => {
      if (pid) catcherInnings[pid] = (catcherInnings[pid] || 0) + 1;
    });
    Object.entries(catcherInnings).forEach(([pid, count]) => {
      if (count >= rules.catcherInningsLimit) {
        const p = playerMap[pid];
        // Check if they're also pitching
        if (currentBattery['P'] && Object.values(currentBattery['P']).includes(pid)) {
          warnings.push(`‚ö†Ô∏è #${p.number} ${p.firstName} catches ${count} innings ‚Äî cannot pitch (rule: ${rules.catcherInningsLimit}+ innings catching)`);
        }
      }
    });
  }

  if (errors.length > 0) {
    html += '<div class="error-box"><div class="error-title">Rule Violations</div>';
    errors.forEach(e => { html += `<div>‚ùå ${e}</div>`; });
    html += '</div>';
  }
  if (warnings.length > 0) {
    html += '<div class="warning-box"><div class="warning-title">Advisory Warnings</div>';
    warnings.forEach(w => { html += `<div>${w}</div>`; });
    html += '</div>';
  }
  if (errors.length === 0 && warnings.length === 0) {
    html += '<div class="success-box">‚úÖ Lineup passes all rules. No warnings.</div>';
  }

  el.innerHTML = html;
}

// ========== SEASON STATS ==========
function renderSeasonStats() {
  const players = getPlayers();
  const games = getGames();
  const lineups = getLineups();
  const rules = getRules();
  const el = document.getElementById('seasonStats');

  if (players.length === 0) {
    el.innerHTML = '<div class="empty-state"><h3>No players</h3><p>Add players to your roster first.</p></div>';
    return;
  }

  const completedGames = games.filter(g => lineups[g.id]);
  
  // Accumulate stats
  const stats = {};
  players.forEach(p => {
    stats[p.id] = { gamesPlayed: 0, infieldInnings: 0, benchInnings: 0, positionCounts: {}, pitchingGames: 0 };
    POSITIONS.forEach(pos => { stats[p.id].positionCounts[pos] = 0; });
  });

  completedGames.forEach(g => {
    const lineup = lineups[g.id].assignments;
    const absent = lineups[g.id].absent || [];
    
    players.forEach(p => {
      if (absent.includes(p.id)) return;
      stats[p.id].gamesPlayed++;
      let pitched = false;
      
      for (let inn = 1; inn <= rules.innings; inn++) {
        if (!lineup[inn]) continue;
        const entry = Object.entries(lineup[inn]).find(([pos, pid]) => pid === p.id && pos !== 'BENCH');
        if (entry) {
          const [pos] = entry;
          stats[p.id].positionCounts[pos] = (stats[p.id].positionCounts[pos] || 0) + 1;
          if (INFIELD.includes(pos)) stats[p.id].infieldInnings++;
          if (pos === 'P') pitched = true;
        }
        if ((lineup[inn]['BENCH'] || []).includes(p.id)) stats[p.id].benchInnings++;
      }
      if (pitched) stats[p.id].pitchingGames++;
    });
  });

  let html = `<p style="margin-bottom:12px;">${completedGames.length} of ${games.length} games with lineups</p>`;
  html += '<table><thead><tr><th>#</th><th>Name</th><th>GP</th>';
  POSITIONS.forEach(pos => { html += `<th>${pos}</th>`; });
  html += '<th>IF</th><th>BN</th><th>Pitched</th><th>Pitch Req</th></tr></thead><tbody>';

  players.sort((a,b) => a.number - b.number).forEach(p => {
    const s = stats[p.id];
    const pitchMet = s.pitchingGames >= 1;
    html += `<tr>
      <td>${p.number}</td>
      <td>${p.firstName} ${p.lastName}</td>
      <td>${s.gamesPlayed}</td>`;
    POSITIONS.forEach(pos => { html += `<td>${s.positionCounts[pos] || 0}</td>`; });
    html += `<td>${s.infieldInnings}</td>
      <td>${s.benchInnings}</td>
      <td>${s.pitchingGames}</td>
      <td class="${pitchMet ? 'stat-met' : 'stat-unmet'}">${pitchMet ? '‚úÖ' : '‚ùå'}</td>
    </tr>`;
  });
  html += '</tbody></table>';
  el.innerHTML = html;
}

// ========== RULES PAGE ==========
function renderRulesPage() {
  const rules = getRules();
  
  // Set form values
  document.getElementById('rule-innings').value = rules.innings;
  document.getElementById('rule-rosterSize').value = rules.rosterSize;
  document.getElementById('rule-fielders').value = rules.fielders;
  document.getElementById('rule-minInfield').value = rules.minInfield;
  document.getElementById('rule-minPitchBatters').value = rules.minPitchBatters;
  document.getElementById('rule-homeDugout').value = rules.homeDugout;
  document.getElementById('rule-catcherInningsLimit').value = rules.catcherInningsLimit;
  document.getElementById('rule-pitcherPitchLimit').value = rules.pitcherPitchLimit;
  document.getElementById('rule-pitcherReturnLimit').value = rules.pitcherReturnLimit;

  // Skill attributes
  const attrEl = document.getElementById('skillAttrList');
  let attrHtml = '<div style="display:flex;flex-wrap:wrap;gap:8px;">';
  rules.skillAttributes.forEach((attr, i) => {
    attrHtml += `<div style="display:flex;align-items:center;gap:4px;background:#f8f9fa;padding:4px 8px;border-radius:4px;font-size:0.85rem;">
      ${attr} <button class="btn btn-danger btn-sm" style="padding:1px 6px;font-size:0.7rem;" onclick="removeSkillAttribute(${i})">‚úï</button>
    </div>`;
  });
  attrHtml += '</div>';
  attrEl.innerHTML = attrHtml;

  // Strategies
  const stratEl = document.getElementById('strategyList');
  let stratHtml = '';
  rules.strategies.forEach((s, i) => {
    stratHtml += `<div style="display:flex;align-items:center;gap:8px;padding:6px 0;border-bottom:1px solid var(--border);font-size:0.85rem;">
      <span style="flex:1;">${s}</span>
      <button class="btn btn-danger btn-sm" style="padding:1px 6px;font-size:0.7rem;" onclick="removeStrategy(${i})">‚úï</button>
    </div>`;
  });
  stratEl.innerHTML = stratHtml;
}

function saveRules() {
  const rules = getRules();
  rules.innings = parseInt(document.getElementById('rule-innings').value);
  rules.rosterSize = parseInt(document.getElementById('rule-rosterSize').value);
  rules.fielders = parseInt(document.getElementById('rule-fielders').value);
  rules.minInfield = parseInt(document.getElementById('rule-minInfield').value);
  rules.minPitchBatters = parseInt(document.getElementById('rule-minPitchBatters').value);
  rules.homeDugout = document.getElementById('rule-homeDugout').value;
  rules.catcherInningsLimit = parseInt(document.getElementById('rule-catcherInningsLimit').value);
  rules.pitcherPitchLimit = parseInt(document.getElementById('rule-pitcherPitchLimit').value);
  rules.pitcherReturnLimit = parseInt(document.getElementById('rule-pitcherReturnLimit').value);
  saveRulesData(rules);
}

function addSkillAttribute() {
  const input = document.getElementById('newSkillAttr');
  const name = input.value.trim();
  if (!name) return;
  const rules = getRules();
  if (rules.skillAttributes.includes(name)) { alert('Attribute already exists.'); return; }
  rules.skillAttributes.push(name);
  saveRulesData(rules);
  input.value = '';
  renderRulesPage();
}

function removeSkillAttribute(i) {
  const rules = getRules();
  if (!confirm(`Remove "${rules.skillAttributes[i]}"?`)) return;
  rules.skillAttributes.splice(i, 1);
  saveRulesData(rules);
  renderRulesPage();
}

function addStrategy() {
  const input = document.getElementById('newStrategy');
  const text = input.value.trim();
  if (!text) return;
  const rules = getRules();
  rules.strategies.push(text);
  saveRulesData(rules);
  input.value = '';
  renderRulesPage();
}

function removeStrategy(i) {
  const rules = getRules();
  rules.strategies.splice(i, 1);
  saveRulesData(rules);
  renderRulesPage();
}

// ========== SEED DATA ==========
function loadSeedData() {
  if (getPlayers().length > 0 && !confirm('This will replace your current roster. Continue?')) return;
  
  const players = [
    { id:'p1', firstName:'Jake', lastName:'Miller', number:1, canPitch:true, canCatch:false, skills:{'Fielding Ability':4,'Outfield Ability':3,'Infield Catching Ability':4,'Arm Accuracy':4,'Arm Strength':4,'Baseball IQ':5,'Coachability':5,'Attitude':5,'Impact on Teammates':5,'Agility':4} },
    { id:'p2', firstName:'Ryan', lastName:'Chen', number:3, canPitch:true, canCatch:true, skills:{'Fielding Ability':5,'Outfield Ability':3,'Infield Catching Ability':5,'Arm Accuracy':5,'Arm Strength':5,'Baseball IQ':5,'Coachability':4,'Attitude':4,'Impact on Teammates':4,'Agility':4} },
    { id:'p3', firstName:'Marcus', lastName:'Johnson', number:5, canPitch:false, canCatch:true, skills:{'Fielding Ability':4,'Outfield Ability':2,'Infield Catching Ability':5,'Arm Accuracy':4,'Arm Strength':4,'Baseball IQ':4,'Coachability':5,'Attitude':5,'Impact on Teammates':4,'Agility':3} },
    { id:'p4', firstName:'Ethan', lastName:'Williams', number:7, canPitch:true, canCatch:false, skills:{'Fielding Ability':3,'Outfield Ability':4,'Infield Catching Ability':3,'Arm Accuracy':4,'Arm Strength':5,'Baseball IQ':3,'Coachability':3,'Attitude':4,'Impact on Teammates':3,'Agility':4} },
    { id:'p5', firstName:'Diego', lastName:'Martinez', number:9, canPitch:false, canCatch:false, skills:{'Fielding Ability':4,'Outfield Ability':4,'Infield Catching Ability':3,'Arm Accuracy':3,'Arm Strength':3,'Baseball IQ':4,'Coachability':4,'Attitude':5,'Impact on Teammates':5,'Agility':5} },
    { id:'p6', firstName:'Noah', lastName:'Taylor', number:11, canPitch:true, canCatch:false, skills:{'Fielding Ability':3,'Outfield Ability':3,'Infield Catching Ability':2,'Arm Accuracy':3,'Arm Strength':3,'Baseball IQ':3,'Coachability':4,'Attitude':4,'Impact on Teammates':4,'Agility':3} },
    { id:'p7', firstName:'Liam', lastName:'Anderson', number:13, canPitch:false, canCatch:false, skills:{'Fielding Ability':2,'Outfield Ability':3,'Infield Catching Ability':2,'Arm Accuracy':2,'Arm Strength':2,'Baseball IQ':3,'Coachability':5,'Attitude':5,'Impact on Teammates':5,'Agility':3} },
    { id:'p8', firstName:'Owen', lastName:'Thomas', number:15, canPitch:false, canCatch:false, skills:{'Fielding Ability':3,'Outfield Ability':4,'Infield Catching Ability':2,'Arm Accuracy':3,'Arm Strength':4,'Baseball IQ':3,'Coachability':3,'Attitude':3,'Impact on Teammates':3,'Agility':4} },
    { id:'p9', firstName:'Caleb', lastName:'Jackson', number:17, canPitch:true, canCatch:false, skills:{'Fielding Ability':4,'Outfield Ability':3,'Infield Catching Ability':4,'Arm Accuracy':4,'Arm Strength':3,'Baseball IQ':4,'Coachability':4,'Attitude':4,'Impact on Teammates':4,'Agility':3} },
    { id:'p10', firstName:'Aiden', lastName:'White', number:19, canPitch:false, canCatch:true, skills:{'Fielding Ability':3,'Outfield Ability':2,'Infield Catching Ability':4,'Arm Accuracy':3,'Arm Strength':3,'Baseball IQ':3,'Coachability':4,'Attitude':5,'Impact on Teammates':4,'Agility':2} },
    { id:'p11', firstName:'Lucas', lastName:'Harris', number:21, canPitch:false, canCatch:false, skills:{'Fielding Ability':2,'Outfield Ability':2,'Infield Catching Ability':2,'Arm Accuracy':2,'Arm Strength':2,'Baseball IQ':2,'Coachability':4,'Attitude':5,'Impact on Teammates':4,'Agility':3} },
    { id:'p12', firstName:'Mason', lastName:'Clark', number:23, canPitch:false, canCatch:false, skills:{'Fielding Ability':3,'Outfield Ability':3,'Infield Catching Ability':3,'Arm Accuracy':3,'Arm Strength':3,'Baseball IQ':3,'Coachability':3,'Attitude':3,'Impact on Teammates':3,'Agility':3} }
  ];
  savePlayers(players);

  const games = [
    { id:'g1', opponent:'Eagles', date:'2026-04-05', time:'10:00', location:'Lincoln Park Field 1', homeAway:'home' },
    { id:'g2', opponent:'Hawks', date:'2026-04-12', time:'13:00', location:'Riverside Diamond', homeAway:'away' },
    { id:'g3', opponent:'Tigers', date:'2026-04-19', time:'10:00', location:'Lincoln Park Field 1', homeAway:'home' },
    { id:'g4', opponent:'Bears', date:'2026-04-26', time:'14:00', location:'Oakwood Field', homeAway:'away' },
    { id:'g5', opponent:'Wolves', date:'2026-05-03', time:'11:00', location:'Lincoln Park Field 2', homeAway:'home' }
  ];
  saveGames(games);

  renderRoster();
  alert('Sample data loaded: 12 players and 5 games.');
}

// ========== EXPORT / IMPORT ==========
function exportData() {
  const data = {
    exportDate: new Date().toISOString(),
    appVersion: 'LineupIQ v1',
    players: getPlayers(),
    games: getGames(),
    rules: getRules(),
    lineups: getLineups(),
    battingOrder: getBattingOrder(),
    evalHistory: getEvalHistory()
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `lineupiq-backup-${new Date().toISOString().slice(0,10)}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

function importData(event) {
  const file = event.target.files[0];
  if (!file) return;
  if (!confirm('This will replace ALL current data. Continue?')) { event.target.value = ''; return; }
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = JSON.parse(e.target.result);
      if (data.players) savePlayers(data.players);
      if (data.games) saveGames(data.games);
      if (data.rules) saveRulesData(data.rules);
      if (data.lineups) saveLineups(data.lineups);
      if (data.battingOrder) saveBattingOrder(data.battingOrder);
      if (data.evalHistory) saveEvalHistory(data.evalHistory);
      renderRoster();
      alert('Data restored successfully!');
    } catch (err) {
      alert('Error reading file: ' + err.message);
    }
  };
  reader.readAsText(file);
  event.target.value = '';
}

// ========== AUTH ==========
const APP_CODE = 'Baseball55123';

function checkPassword() {
  const input = document.getElementById('loginPassword').value;
  if (input === APP_CODE) {
    sessionStorage.setItem('liq_auth', 'true');
    showApp();
  } else {
    document.getElementById('loginError').style.display = 'block';
  }
}

function showApp() {
  document.getElementById('loginScreen').style.display = 'none';
  document.getElementById('appHeader').style.display = '';
  document.getElementById('mainNav').style.display = '';
  document.getElementById('appMain').style.display = '';
}

// ========== INIT ==========
if (sessionStorage.getItem('liq_auth') === 'true') {
  showApp();
} else {
  document.getElementById('loginScreen').style.display = 'flex';
}
// Start real-time sync with Firestore, then render
initRealtimeSync();
renderRoster();

// Register service worker for PWA
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(() => {});
}
</script>
</body>
</html>
